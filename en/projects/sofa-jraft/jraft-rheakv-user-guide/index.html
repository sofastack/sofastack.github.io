<!DOCTYPE html>
<html>

<head>
	<title>
	JRaft RheaKV user guide · SOFAStack
</title>
	<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="SOFAStack is a Scalable Open Financial Architecture for building cloud native applications" />

<meta name="generator" content="Hugo 0.55.5" /><link rel="shortcut icon" href=https://gw.alipayobjects.com/os/q/cms/images/jqu9346l/4ba95631-2489-4885-881f-bc7f8d787d5e_w64_h61.png type="image/png">

<link href="https://unpkg.com/purecss@1.0.0/build/base-min.css" rel="stylesheet">



<link href="/sofastack.tech/css/main.css" rel="stylesheet">
<link href="/sofastack.tech/css/zoom-image.css" rel="stylesheet">

<script src="/sofastack.tech/js/iconfont.js"></script>
<script src="/sofastack.tech/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<script>window.SITE_LANGUAGE = "en"</script>
<script src="/sofastack.tech/js/app.js"></script>





<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-142131411-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</head>

<body>
	<header class="ss-header">
	<nav class="navbar" role="navigation" aria-label="main navigation">
		<div class="navbar-brand">
			<a class="logo-link" href="/sofastack.tech/en/">
				<img class="logo" src="/sofastack.tech/img/logo.png">
			</a>
			<div class="-show-mobile">
				<a id="mobile-menu-icon">
					<svg class="icon" aria-hidden="true">
						<use xlink:href="#icon-menu"></use>
					</svg>
				</a>
				<nav id="mobile-menu">
						<div id="js-menu-search-mobile" class="navbar-search-mobile">
							<input class="input" placeholder="Search">
							<svg class="icon" aria-hidden="true">
								<use xlink:href="#icon-search"></use>
							</svg>
						</div>
					
          
            <a
              class=""
              href="/sofastack.tech/en/projects/">
              <span>
                Projects
              </span>
              <svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"></use></svg>
            </a>
					
            <a
              class=""
              href="/sofastack.tech/en/guides/">
              <span>
                Guides
              </span>
              <svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"></use></svg>
            </a>
					
            <a
              class=""
              href="/sofastack.tech/en/blog/">
              <span>
                Blog
              </span>
              <svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"></use></svg>
            </a>
					
            <a
              class=""
              href="/sofastack.tech/en/activities/">
              <span>
                Activity
              </span>
              <svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"></use></svg>
            </a>
					
            <a
              class=""
              href="/sofastack.tech/awesome/">
              <span>
                Awesome SOFA
              </span>
              <svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"></use></svg>
            </a>
					
					
            
              <a href="/sofastack.tech/projects/sofa-jraft/jraft-rheakv-user-guide/">
                <span>中文</span>
                <svg class="icon" aria-hidden="true"><use xlink:href="#icon-transfer"></use></svg>
              </a>
						
					
				</nav>
			</div>
		</div>

		<div class="navbar-menu -hidden-mobile">
			<div class="navbar-start">
				
				
					<a class="navbar-item "
						href="/sofastack.tech/en/projects/">Projects</a>
				
					<a class="navbar-item "
						href="/sofastack.tech/en/guides/">Guides</a>
				
					<a class="navbar-item "
						href="/sofastack.tech/en/blog/">Blog</a>
				
					<a class="navbar-item "
						href="/sofastack.tech/en/activities/">Activity</a>
				
					<a class="navbar-item "
						href="/sofastack.tech/awesome/">Awesome SOFA</a>
				
			</div>
			<div class="navbar-end">
				<div class="navbar-item">
					<div id="js-menu-search" class="navbar-search">
						<input class="input" placeholder="Search">
						<svg class="icon" aria-hidden="true">
							<use xlink:href="#icon-search"></use>
						</svg>
					</div>
				</div>
				<div class="navbar-item">
					
						
							<a class="translation" href="/sofastack.tech/projects/sofa-jraft/jraft-rheakv-user-guide/">中</a>
						
					
				</div>
			</div>
		</div>
	</nav>
</header>


	

	

	

	

	



	

<div class="ss-layout-container">
	<aside class="ss-layout-aside -left ss-card -soft-hidden">
		






	<div id="js-drawer" class="ss-toc">
		<div id="js-drawer-handle" class="drawer-handle">
			<svg class="icon icon-menu" aria-hidden="true">
				<use xlink:href="#icon-menu"></use>
			</svg>
			<svg class="icon icon-close" aria-hidden="true">
				<use xlink:href="#icon-close"></use>
			</svg>
		</div>
		<div class="drawer-body">
			<div class="header" title="SOFAJRaft is a production-level high-performance Java implementation based on the RAFT consensus algorithm. It supports MULTI-RAFT-GROUP and is suitable for high-load and low-latency scenarios. ">SOFAJRaft

































































































































































































































































































































































































































































































<div class="ss-toc-list-card -hidden-mobile">
	<svg class="icon -hidden-mobile" aria-hidden="true">
		<use xlink:href="#icon-menu1"></use>
	</svg>
	<div class="ss-tooltip">
		
		
		<div class="toc-list">
			<h4 class="title">Main Projects</h4>
			<ul class="list">
				
				<li class="item">
					
					
					
					
					<a href=/sofastack.tech/en/projects/sofa-boot/overview/>
						SOFABoot
					</a>
				</li>
				
				<li class="item">
					
					
					
					
					<a href=/sofastack.tech/en/projects/sofa-rpc/overview/>
						SOFARPC
					</a>
				</li>
				
				<li class="item">
					
					
					
					
					<a href=/sofastack.tech/en/projects/sofa-tracer/overview/>
						SOFATracer
					</a>
				</li>
				
				<li class="item">
					
					
					
					
					<a href=/sofastack.tech/en/projects/sofa-lookout/overview/>
						SOFALookout
					</a>
				</li>
				
				<li class="item">
					
					
					
					
					<a href=/sofastack.tech/en/projects/sofa-registry/overview/>
						SOFARegistry
					</a>
				</li>
				
			</ul>
		</div>
		
		
		
		<div class="toc-list">
			<h4 class="title">Incubating Projects</h4>
			<ul class="list">
				
				<li class="item">
					
					
					
					
					<a href=/sofastack.tech/en/projects/sofa-mesh/overview/>
						SOFAMesh
					</a>
				</li>
				
				<li class="item">
					
					
					
					
					<a href=/sofastack.tech/en/projects/sofa-dashboard/overview/>
						SOFADashboard
					</a>
				</li>
				
			</ul>
		</div>
		
		
		
		<div class="toc-list">
			<h4 class="title">Tool Projects</h4>
			<ul class="list">
				
				<li class="item">
					
					
					
					
					<a href=/sofastack.tech/en/projects/sofa-bolt/overview/>
						SOFABolt
					</a>
				</li>
				
				<li class="item">
					
					
					
					
					<a href=/sofastack.tech/en/projects/sofa-jraft/overview/>
						SOFAJRaft
					</a>
				</li>
				
				<li class="item">
					
					
					
					
					<a href=/sofastack.tech/en/projects/sofa-acts/overview/>
						SOFAActs
					</a>
				</li>
				
				<li class="item">
					
					
					
					
					
					
					<a href=https://www.sofastack.tech/en/projects/sofa-boot/sofa-ark-readme//>
						SOFAArk
					</a>
				</li>
				
			</ul>
		</div>
		
		
		
		<div class="toc-list">
			<h4 class="title">Ecosystem Projects</h4>
			<ul class="list">
				
				<li class="item">
					
					
					
					
					
					
					<a href=https://mosn.io/en/>
						MOSN
					</a>
				</li>
				
				<li class="item">
					
					
					
					
					
					
					<a href=https://occlum.io/>
						Occlum
					</a>
				</li>
				
				<li class="item">
					
					
					
					
					
					
					<a href=https://seata.io/>
						Seata
					</a>
				</li>
				
				<li class="item">
					
					
					
					
					
					
					<a href=https://mosn.io/layotto/>
						Layotto
					</a>
				</li>
				
			</ul>
		</div>
		
		
	</div>
</div>

			</div>
			<div class="body">
				



<ul class="leaf-section">
	
		
			<li class="item">
				<div class="link">
					<a
						title="SOFAJRaft overview"
						href="/sofastack.tech/en/projects/sofa-jraft/overview/"
					>SOFAJRaft overview</a>
				</div>
			</li>
		
		
	
		
			<li class="item">
				<div class="link">
					<a
						title="Engine architecture"
						href="/sofastack.tech/en/projects/sofa-jraft/engine-architecture/"
					>Engine architecture</a>
				</div>
			</li>
		
		
	
		
			<li class="item">
				<div class="link">
					<a
						title="Jepsen tests"
						href="/sofastack.tech/en/projects/sofa-jraft/jepson-test/"
					>Jepsen tests</a>
				</div>
			</li>
		
		
	
		
		
			<li class="item">
				<div class="link">
					<svg class="icon arrow" aria-hidden="true">
						<use xlink:href="#icon-arrow"></use>
					</svg>
					<a
						title="User guide"
					>User guide</a>
				</div>
				



<ul class="leaf-section">
	
		
			<li class="item">
				<div class="link">
					<a
						title="JRaft user guide"
						href="/sofastack.tech/en/projects/sofa-jraft/jraft-user-guide/"
					>JRaft user guide</a>
				</div>
			</li>
		
		
	
		
			<li class="item">
				<div class="link -current">
					<a
						title="JRaft RheaKV user guide"
						href="/sofastack.tech/en/projects/sofa-jraft/jraft-rheakv-user-guide/"
					>JRaft RheaKV user guide</a>
				</div>
			</li>
		
		
	
		
			<li class="item">
				<div class="link">
					<a
						title="Counter example"
						href="/sofastack.tech/en/projects/sofa-jraft/counter-example/"
					>Counter example</a>
				</div>
			</li>
		
		
	
</ul>
			</li>
		
	
		
			<li class="item">
				<div class="link">
					<a
						title="Maven dependency description&#39;"
						href="/sofastack.tech/en/projects/sofa-jraft/maven-dependency/"
					>Maven dependency description&#39;</a>
				</div>
			</li>
		
		
	
		
			<li class="item">
				<div class="link">
					<a
						title="Release notes"
						href="/sofastack.tech/en/projects/sofa-jraft/release-log/"
					>Release notes</a>
				</div>
			</li>
		
		
	
		
			<li class="item">
				<div class="link">
					<a
						title="Benchmark data"
						href="/sofastack.tech/en/projects/sofa-jraft/benchmark-performance/"
					>Benchmark data</a>
				</div>
			</li>
		
		
	
		
			<li class="item">
				<div class="link">
					<a
						title="User stories"
						href="/sofastack.tech/en/projects/sofa-jraft/user-stories/"
					>User stories</a>
				</div>
			</li>
		
		
	
		
			<li class="item">
				<div class="link">
					<a
						title="Roadmap"
						href="/sofastack.tech/en/projects/sofa-jraft/road-map/"
					>Roadmap</a>
				</div>
			</li>
		
		
	
		
		
			<li class="item">
				<div class="link">
					<svg class="icon arrow" aria-hidden="true">
						<use xlink:href="#icon-arrow"></use>
					</svg>
					<a
						title="Related articles"
					>Related articles</a>
				</div>
				



<ul class="leaf-section">
	
		
			<li class="item">
				<div class="link">
					<a
						title="Introduction to Raft algorithms"
						href="/sofastack.tech/en/projects/sofa-jraft/raft-introduction/"
					>Introduction to Raft algorithms</a>
				</div>
			</li>
		
		
	
		
			<li class="item">
				<div class="link">
					<a
						title="Distributed consensus - Raft and JRaft"
						href="/sofastack.tech/en/projects/sofa-jraft/consistency-raft-jraft/"
					>Distributed consensus - Raft and JRaft</a>
				</div>
			</li>
		
		
	
</ul>
			</li>
		
	
		
		
			<li class="item">
				<div class="link">
					<svg class="icon arrow" aria-hidden="true">
						<use xlink:href="#icon-arrow"></use>
					</svg>
					<a
						title="Other"
					>Other</a>
				</div>
				



<ul class="leaf-section">
	
		
			<li class="item">
				<div class="link">
					<a
						title="How to contribute to SOFAJRaft"
						href="/sofastack.tech/en/projects/sofa-jraft/how-to-contribute-code-to-sofajraft/"
					>How to contribute to SOFAJRaft</a>
				</div>
			</li>
		
		
	
</ul>
			</li>
		
	
</ul>
			</div>
		</div>
	</div>

	</aside>

	<main class="ss-layout-main -card">
		




<div class="ss-meta">
	<div class="container">
		<h1 class="title">
			JRaft RheaKV user guide
		</h1>
		<a class="edit-button -hidden-mobile"
			href="https://github.com/sofastack/sofastack.tech/edit/master/content/en/projects/sofa-jraft/jraft-rheakv-user-guide/index.md"
		>Edit</a>
	</div>
	<div class="meta">
		Update time: 2024-06-18 
		
			
		
	</div>
</div>

		<article class="typo">
  <h2 id="introduction-to-rheakv">Introduction to RheaKV</h2>

<p>RheaKV is a lightweight, distributed, and embedded KV storage library, which is included in the JRaft project as a submodule.</p>

<p><strong>Features</strong></p>

<ol>
<li>Embedded: RheaKV is embedded in applications in the form of Jar files.</li>
<li>Strong consistency: RheaKV ensures data reliability and consistency based on the multi-raft distributed consensus protocol.</li>
<li>Self-driven (not fully implemented at present): RheaKV supports automatic diagnosis, optimization, decision making, and recovery.</li>
<li>Monitorable: RheaKV automatically reports meta information and state information by node to the PD.</li>
<li>Basic APIs: get, put, and delete; cross-region APIs: scan, batch put, and distributed lock.</li>
</ol>

<h2 id="architecture-design">Architecture design</h2>

<p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*6K1mTq0z-TkAAAAAAAAAAABjARQnAQ" alt="Architecture design" /></p>

<h2 id="terms-and-definitions">Terms and definitions</h2>

<ul>
<li>PD: The global central master node that is responsible for scheduling the entire cluster. A PD server can manage multiple clusters, with each of them isolated by clusterId. The PD server requires separate deployment. Actually, many scenarios do not need automatic cluster management, and RheaKV does not support PD.</li>
<li>Store: A physical storage node within a cluster. A store may contain one or more regions.</li>
<li>Region: The minimal KV data unit. Each region can be understood as a database partition or database shard, and has a left closed and right open interval [startKey, endKey).</li>
</ul>

<h2 id="storage-design">Storage design</h2>

<ul>
<li>The storage layer adopts a pluggable design and supports both MemoryDB and RocksDB currently:

<ul>
<li>MemoryDB is implemented based on ConcurrentSkipListMap and provides better performance. However, its independent storage capacity is restricted by the memory.</li>
<li><a href="https://github.com/facebook/rocksdb">RocksDB</a> is suitable for scenarios with large data volumes, because its storage capacity is only restricted by the disk.</li>
</ul></li>
<li>Strong data consistency is ensured. RheaKV synchronizes data to other replicas with the help of JRaft, and each data change is recorded as a Raft log entry. The log replication feature of Raft ensures all data is securely and reliably synchronized to all nodes within the same Raft group.</li>
</ul>

<h2 id="scenarios">Scenarios</h2>

<ul>
<li>Lightweight state/meta information storage and cluster synchronization</li>
<li>Distributed lock service</li>
</ul>

<h2 id="api-description">API description</h2>

<p>Generally, RheaKV APIs are divided into two types: synchronous APIs and asynchronous APIs. Methods whose names start with letter b (block) are synchronous blocking APIs, and the rest are asynchronous APIs. All asynchronous APIs return the same <code>CompletableFuture</code> parameter. The read method may contain another important parameter, that is readOnlySafe. When this parameter is set to true, linearizable read is supported. Read methods that do not contain this parameter provide linearizable read by default.</p>

<h3 id="get">get</h3>

<pre><code class="language-java">CompletableFuture&lt;byte[]&gt; get(final byte[] key);
CompletableFuture&lt;byte[]&gt; get(final String key);
CompletableFuture&lt;byte[]&gt; get(final byte[] key, final boolean readOnlySafe);
CompletableFuture&lt;byte[]&gt; get(final String key, final boolean readOnlySafe);
byte[] bGet(final byte[] key);
byte[] bGet(final String key);
byte[] bGet(final byte[] key, final boolean readOnlySafe);
byte[] bGet(final String key, final boolean readOnlySafe);
</code></pre>

<ol>
<li>For String type input parameters, RheaKV provides more efficient UTF-8 String encoder/decoder APIs for internal use. If the business key is String, we recommend that you directly use the API of the String parameter.</li>
<li>If linearizable read is not required, you can set the readOnlySafe parameter to false. Then the load balancer will make on-premises calls with priority. If the required service is not available locally, the load balancer will poll a remote server to send read requests.</li>
</ol>

<h3 id="multiget">multiGet</h3>

<pre><code class="language-java">CompletableFuture&lt;Map&lt;ByteArray, byte[]&gt;&gt; multiGet(final List&lt;byte[]&gt; keys);
CompletableFuture&lt;Map&lt;ByteArray, byte[]&gt;&gt; multiGet(final List&lt;byte[]&gt; keys, final boolean readOnlySafe);
Map&lt;ByteArray, byte[]&gt; bMultiGet(final List&lt;byte[]&gt; keys);
Map&lt;ByteArray, byte[]&gt; bMultiGet(final List&lt;byte[]&gt; keys, final boolean readOnlySafe);
</code></pre>

<ol>
<li>The multiGet API supports cross-region query. RheaKV automatically works out the region of each key internally, initiates parallel calls, and then combines the query results.</li>
<li>To place the byte[] in HashMap, we use a workaround to make the key of Map in the return value as a ByteArray object, which can be considered as a wrapper of byte[]. This achieves the same effect as hashing byte[].</li>
</ol>

<h3 id="scan-iterator">scan &amp; iterator</h3>

<pre><code class="language-java">CompletableFuture&lt;List&lt;KVEntry&gt;&gt; scan(final byte[] startKey, final byte[] endKey);
CompletableFuture&lt;List&lt;KVEntry&gt;&gt; scan(final String startKey, final String endKey);
CompletableFuture&lt;List&lt;KVEntry&gt;&gt; scan(final byte[] startKey, final byte[] endKey, final boolean readOnlySafe);
CompletableFuture&lt;List&lt;KVEntry&gt;&gt; scan(final String startKey, final String endKey, final boolean readOnlySafe);
List&lt;KVEntry&gt; bScan(final byte[] startKey, final byte[] endKey);
List&lt;KVEntry&gt; bScan(final String startKey, final String endKey);
List&lt;KVEntry&gt; bScan(final byte[] startKey, final byte[] endKey, final boolean readOnlySafe);
List&lt;KVEntry&gt; bScan(final String startKey, final String endKey, final boolean readOnlySafe);

RheaIterator&lt;KVEntry&gt; iterator(final byte[] startKey, final byte[] endKey, final int bufSize);
RheaIterator&lt;KVEntry&gt; iterator(final String startKey, final String endKey, final int bufSize);
RheaIterator&lt;KVEntry&gt; iterator(final byte[] startKey, final byte[] endKey, final int bufSize, final boolean readOnlySafe);
RheaIterator&lt;KVEntry&gt; iterator(final String startKey, final String endKey, final int bufSize, final boolean readOnlySafe);
</code></pre>

<ol>
<li>Both scan and iterator contain two input parameters, which are <code>StartKey</code> and <code>EndKey</code>. Their ranges are left closed and right open intervals as <code>[StartKey, endKey)</code></li>
<li>The difference between iterator and scan is that iterator can be considered a lazy mode. When calling the <code>HasNext ()</code> method, it triggers the data request operation only when no data is available in the local buffer (bufSize is the buffer size).</li>
<li>The scan API supports cross-region scanning. RheaKV automatically works out all regions covered by the range between the <code>StartKey</code> and the <code>EndKey</code>, and initiates parallel calls. The process is slow if regions that contain large amounts of data are to be scanned. Bear in mind that you should avoid scanning too many regions at one time.</li>
<li><code>startKey</code> can be set to null, which indicates minStartKey. <code>endKey</code> can also be set to null, which indicates maxEndKey. However, as mentioned above, you should avoid large-range queries.</li>
</ol>

<h3 id="getsequence-resetsequence">getSequence &amp; resetSequence</h3>

<pre><code class="language-java">// Get sequence
CompletableFuture&lt;Sequence&gt; getSequence(final byte[] seqKey, final int step);
CompletableFuture&lt;Sequence&gt; getSequence(final String seqKey, final int step);
Sequence bGetSequence(final byte[] seqKey, final int step);
Sequence bGetSequence(final String seqKey, final int step);
// Reset sequence
CompletableFuture&lt;Boolean&gt; resetSequence(final byte[] seqKey);
CompletableFuture&lt;Boolean&gt; resetSequence(final String seqKey);
Boolean bResetSequence(final byte[] seqKey);
Boolean bResetSequence(final String seqKey);
</code></pre>

<ol>
<li>You can call the <code>getSequence</code> method to get a globally monotonically increasing sequence. For example, if the step is 10, the request result will be [n, n + 10), which is a left-closed and right-open interval. Sequence data is stored separately from common key-value data. Therefore, it cannot be deleted by common APIs, and you do not have to worry about sequence data being deleted by mistake. Sequence data can be reset manually by using the resetSequence method, which is described next.</li>
<li>Note that generally we do not recommend that you use the <code>resetSequence</code> methods. They are provided to help you manually reset sequence data in unexpected events.</li>
</ol>

<h3 id="put">put</h3>

<pre><code class="language-java">CompletableFuture&lt;Boolean&gt; put(final byte[] key, final byte[] value);
CompletableFuture&lt;Boolean&gt; put(final String key, final byte[] value);
Boolean bPut(final byte[] key, final byte[] value);
Boolean bPut(final String key, final byte[] value);
</code></pre>

<ol>
<li>This API is provided in all KV systems. For more information about the string-type input parameters, see description of the get API.</li>
</ol>

<h3 id="getandput">getAndPut</h3>

<pre><code class="language-java">CompletableFuture&lt;byte[]&gt; getAndPut(final byte[] key, final byte[] value);
CompletableFuture&lt;byte[]&gt; getAndPut(final String key, final byte[] value);
byte[] bGetAndPut(final byte[] key, final byte[] value);
byte[] bGetAndPut(final String key, final byte[] value);
</code></pre>

<ol>
<li>This API provides the atomic semantics of &ldquo;getting the old value and putting the new value.&rdquo; For more information about the string-type input parameters, see description of the get API.</li>
</ol>

<h3 id="merge">merge</h3>

<pre><code class="language-java">CompletableFuture&lt;Boolean&gt; merge(final String key, final String value);
Boolean bMerge(final String key, final String value);
</code></pre>

<ol>
<li>Currently, the merge API only supports String-type operations.</li>
<li>This API provides an atomic merge operation for the use in scenarios that require the initial use of the get API and then the put API. The following code shows how it works.</li>
</ol>

<pre><code class="language-java">// Writing aa under key
db.put(&quot;key&quot;, &quot;aa&quot;);
// Writing bb under key
db.merge(&quot;key&quot;, &quot;bb&quot;);
    
assertThat(db.get(&quot;key&quot;)).isEqualTo(&quot;aa,bb&quot;);
</code></pre>

<h3 id="batch-put">batch put</h3>

<pre><code class="language-java">CompletableFuture&lt;Boolean&gt; put(final List&lt;KVEntry&gt; entries);
boolean bPut(final List&lt;KVEntry&gt; entries);
</code></pre>

<ol>
<li>This API supports cross-region operations. RheaKV automatically works out the regions of each key internally and initiates parallel calls.</li>
<li>Note that this operation cannot provide a transaction guarantee for the time being. It can not guarantee &ldquo;all successful or all failed&rdquo;. However, RheaKV supports failover retries to reduce the chances of this situation occurring.</li>
</ol>

<h3 id="putifabsent">putIfAbsent</h3>

<pre><code class="language-java">CompletableFuture&lt;byte[]&gt; putIfAbsent(final byte[] key, final byte[] value);
CompletableFuture&lt;byte[]&gt; putIfAbsent(final String key, final byte[] value);
byte[] bPutIfAbsent(final byte[] key, final byte[] value);
byte[] bPutIfAbsent(final String key, final byte[] value);
</code></pre>

<ol>
<li>This API provides the atomic semantics: If the key does not exist, put the key. If the key already exists, return only the existing value.</li>
</ol>

<h3 id="delete">delete</h3>

<pre><code class="language-java">CompletableFuture&lt;Boolean&gt; delete(final byte[] key);
CompletableFuture&lt;Boolean&gt; delete(final String key);
Boolean bDelete(final byte[] key);
Boolean bDelete(final String key);
</code></pre>

<ol>
<li>This API deletes the value associated with a specified key.</li>
</ol>

<h3 id="deleterange">deleteRange</h3>

<pre><code class="language-java">CompletableFuture&lt;Boolean&gt; deleteRange(final byte[] startKey, final byte[] endKey);
CompletableFuture&lt;Boolean&gt; deleteRange(final String startKey, final String endKey);
boolean bDeleteRange(final byte[] startKey, final byte[] endKey);
boolean bDeleteRange(final String startKey, final String endKey);
</code></pre>

<ol>
<li>This API deletes all data of keys that fall in the range <code>[startKey, endKey)</code>. Note that this range is a left-closed and right-open interval, which means it does not include the <code>endKey.</code></li>
<li>This API also supports cross-region deletion. RheaKV automatically works out the regions covered by the key range, and initiate parallel calls. Bear in mind that this is a dangerous operation, and you should use it with caution.</li>
</ol>

<h3 id="execute">execute</h3>

<pre><code class="language-java">CompletableFuture&lt;Boolean&gt; execute(final long regionId, final NodeExecutor executor);
Boolean bExecute(final long regionId, final NodeExecutor executor);
</code></pre>

<ol>
<li>This is the only API that is irrelevant to storage. NodeExecutor can perform some operations, for example updating the cache of the current node. Calling this API ensures all nodes in the cluster execute this executor.</li>
<li>This API is not directly available in RheaKVStore. If you need to use it, force switch to <code>DefaultRheaKVStore.</code></li>
</ol>

<h3 id="distributedlock">DistributedLock</h3>

<pre><code class="language-java">DistributedLock&lt;byte[]&gt; getDistributedLock(final byte[] target, final long lease, final TimeUnit unit);
DistributedLock&lt;byte[]&gt; getDistributedLock(final String target, final long lease, final TimeUnit unit);
DistributedLock&lt;byte[]&gt; getDistributedLock(final byte[] target, final long lease, final TimeUnit unit,
                                           final ScheduledExecutorService watchdog);
DistributedLock&lt;byte[]&gt; getDistributedLock(final String target, final long lease, final TimeUnit unit,
                                           final ScheduledExecutorService watchdog);
</code></pre>

<ol>
<li><p>This API gets a distributed lock instance. distributedLock of RheaKV implements reentrantlock, automatic lease renewal, and fencing token.</p></li>

<li><p>target: You can consider the target as the key of a distributed lock, which must be unique for different locks. However, locks are stored separately from other KV data. Therefore, you only need to ensure the uniqueness of the keys within the &ldquo;lock space&rdquo;.</p></li>

<li><p>lease: This API must contain a lease of the lock. If watchdog is empty, the lock will be automatically released upon expiration. In other words, the lease without a watchdog is a timeout.</p></li>

<li><p>watchdog: an automatic renewal scheduler, which must be created and destroyed by the user. The framework is not responsible for the life cycle management of the watchdog. If watchdog is not empty, it will periodically (taking <sup>2</sup>&frasl;<sub>3</sub> of the lease as a cycle) renew the lease of the current lock until the user releases the lock (unlock).</p></li>

<li><p>Note that: distributedLock is a reentrantlock, and therefore <code>lock ()</code> and <code>unlock ()</code> must appear in pairs. For example, when <code>lock ()</code> appears twice, but <code>unlock ()</code> appears only once, you cannot unlock it.</p></li>

<li><p>For more information about the string-type input parameters, see the description of the get API.</p></li>

<li><p><code>boolean tryLock(final byte[] ctx)</code> contains a ctx input parameter, which is used as the custom context data of the current lock requester. If it acquires the lock, other threads and processes will be able to see its ctx.</p></li>

<li><p>The following pseudocode shows how it is used in a simple case:</p></li>
</ol>

<pre><code class="language-java">    DistributedLock&lt;T&gt; lock = ...;
    if (lock.tryLock()) {
        try {
            // manipulate protected state
        } finally {
            lock.unlock();
        }
    } else {
        // perform alternative actions
    }
</code></pre>

<p><strong>Note</strong>: Here is another important method <code>long getFencingToken()</code>. When a client acquires a lock, it can call this method to get the fencing token of the lock. A fencing token is simply a number that increases every time a client acquires the lock. The fencing token can be used to solve the <a href="http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">following problem</a>.</p>

<p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*ZKq8SrSGE90AAAAAAAAAAABjARQnAQ" alt="Distributed lock" /></p>

<p>Figure source: <a href="http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html</a></p>

<h2 id="quick-start">Quick start</h2>

<h3 id="startup-yaml-file-configuration">Startup yaml file configuration</h3>

<pre><code class="language-yaml">##RheaKVStoreOptions
---
# To connect to a PD, you need a clusterID. The PD isolates different services by clusterId. You can skip this step in the no-PD mode.
clusterId: 1
# Each store node contains one or more Raft groups. This field is the name prefix of all Raft group. All Raft group names must follow the prefix.
# [clusterName-regionId] naming rule
clusterName: rhea_test

# PD-related option settings
placementDriverOptions:
# Set fake to true, which means the cluster will be started in the no-PD mode. In the no-PD mode, the cluster does not have the automatic management ability, and all settings are based on this initial configuration file.
  fake: true

# store node-related option settings
storeEngineOptions:
  rocksDBOptions:
# Specify whether to use synchronous flush. Default value: true. Asynchronous flush provides better performance, but it has the risk of data loss in the case of server power outage.
    sync: true
# Specify the KV data storage directory
    dbPath: rhea_db/
 # Specify the Raft log storage directory
  raftDataPath: rhea_raft/
  serverAddress:
# Specify the local host. The local host name is automatically acquired by default. You can also set it by yourself.
    ip: 127.0.0.1
# Required. It specifies the listener port provided by the storage layer for the RPC service.
    port: 8181

# Specify the list of addresses of nodes in the cluster
initialServerList: 127.0.0.1:8181,127.0.0.1:8182,127.0.0.1:8183

# Specify whether to read data only from the leader node. Default value: true. If follower nodes can ensure linearizable reads, you can set it to false. However, if a follower node is far behind the leader at the time of data synchronization,
reading data from this node will cause the request to time out. Then the RheaKV client's failover logic is triggered to read data form the leader node. This causes a rather long read request delay.
onlyLeaderRead: true

# RPC-related option settings
# rpcOptions:

# Specify the number of retry attempts after a failure
failoverRetries: 2
</code></pre>

<h3 id="startup-code">Startup code</h3>

<pre><code class="language-java">final ObjectMapper mapper = new ObjectMapper(new YAMLFactory());
final RheaKVStoreOptions opts = mapper.readValue(new File(&quot;rheakv_conf&quot;), RheaKVStoreOptions.class);
final RheaKVStore rheaKVStore = new DefaultRheaKVStore();
if (rheaKVStore.init(opts)) {
    rheaKVStore.bPut(&quot;hello&quot;, &quot;hello world!!!&quot;)
    byte[] bytesVal = rheaKVStore.get(&quot;hello&quot;);
    System.out.println(new String(bytesVal);
    // ...
    // Have fun !!!
}
</code></pre>

<p>In addition to configuring startup options based on the yaml file, RheaKV also provides a series of XXXConfigured classes to help you set the configuration parameters of RheaKV. For more information about the examples, see the demo of the JRaft-example module.</p>

<h2 id="core-design">Core design</h2>

<h3 id="internal-process-procedure-of-the-kv-module">Internal process procedure of the KV module</h3>

<p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*VsIgSqmCSQUAAAAAAAAAAABjARQnAQ" alt="Internal process procedure of the KV module" /></p>

<h4 id="rheakvstore">RheaKVStore</h4>

<p>The top-level user API. The default implementation is the DefaultRheaKVStore. RheaKVStore is a pure asynchronous implementation. Therefore, technically, RheaKV will not encounter client bottlenecks caused by blocking calls. The implementation of DefaultRheaKVStore provides many features such as request routing, request split, response combination, and failover retry.</p>

<h4 id="placementdriverclient">PlacementDriverClient</h4>

<p>Optional. PlacementDriverClient is a client that communicates with the PlacementDriver Server cluster. You can use it to obtain the complete information of the cluster, including but not limited to the &ldquo;request route table&rdquo;. For no-PD scenarios, RheaKV provides a fake PD client.</p>

<h4 id="regionroutetable">RegionRouteTable</h4>

<p>As a local route table caching component, RegionRouteTable will determine whether or not to refresh data from the PD server cluster based on the specific cause of the KV request failure. It also supports computing the region ID of a single key, or region IDs of multiple key lists or a key range.</p>

<h4 id="loadbalancer">LoadBalancer</h4>

<p>Takes effect while implementing linearizable reads at follower nodes. Currently, only the PR policy is supported.</p>

<h4 id="rheakvrpcservice">RheaKVRpcService</h4>

<p>The RPC client wrapper for KV services. This component implements the failover logic.</p>

<h4 id="regionkvservice">RegionKVService</h4>

<p>The request processing service at the KV server end. A StoreEngine contains multiple RegionKVServices. Each RegionKVService corresponds to a region, and is only responsible for processing requests within its own region.</p>

<h4 id="metricsrawkvstore">MetricsRawKVStore</h4>

<p>Blocks requests for metric measurement.</p>

<h4 id="raftrawkvstore">RaftRawKVStore</h4>

<p>The start of the Raft process in RheaKV.</p>

<h4 id="kvstorestatemachine">KVStoreStateMachine</h4>

<p>Implements the Raft state machine.</p>

<h4 id="rocksrawkvstore">RocksRawKVStore</h4>

<p>The raw RocksDB API encapsulation. Currently, RheaKV also supports the pluggable MemoryDB storage.</p>

<h3 id="internal-process-procedure-of-the-pd-module">Internal process procedure of the PD module</h3>

<p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*38DLRJ_YScUAAAAAAAAAAABjARQnAQ" alt="Internal process procedure of the PD module" /></p>

<h4 id="overview">Overview</h4>

<p>The PD module is designed mainly based on the <a href="https://github.com/tikv/tikv">TiKV</a> design, especially the two types of heartbeats mentioned later in this topic. However, due to the lack of application scenarios, we have not fully implemented automatic management and self-driving of this module. Currently, we have managed to implement the automatic balancing of region leaders of all nodes and the automatic split.</p>

<h4 id="placementdriverclient-metadataclient">PlacementDriverClient &gt; MetadataClient</h4>

<p>MetadataClient is responsible for obtaining cluster meta information and the registration meta information from PD.</p>

<h4 id="storeengine-heartbeatsender">StoreEngine &gt; HeartbeatSender</h4>

<ul>
<li>HeartbeatSender is responsible for sending the heartbeats of the current Store node. The heartbeats contain some state information, and there are two types of heartbeats: StoreHeartbeat and RegionHeartbeat.</li>
<li>PD continuously receives these two types of heartbeat messages from the RheaKV cluster. PD issues specific scheduling instructions in the heartbeat response to the region leaders, and then uses this information as the decision-making basis. In addition, PD should be able to receive additional operation instructions through the management interface for more accurate manual decision making.</li>

<li><p>The detailed content of state information contained in these two types of heartbeats is as follows:</p>

<ul>
<li>StoreHeartbeat</li>
</ul>

<pre><code class="language-java">     public class StoreStats implements Serializable {
        private long            storeId;
        // Total capacity (disk) of the Store node
        private long            capacity;
        // Available capacity of the Store node
        private long            available;
        // The number of regions on the Store node
        private int             regionCount;
        // The number of snapshots being sent
        private int             sendingSnapCount;
        // The number of snapshots being received
        private int             receivingSnapCount;
        // The number of regions that are applying snapshots
        private int             applyingSnapCount;
        // The startup time of the Store node (unix timestamp in milliseconds)
        private long            startTime;
        // Whether the Store node is busy
        private boolean         isBusy;
        // The actual disk usage of the Store node
        private long            usedSize;
        // The amount of data written in the current heartbeat interval
        private long            bytesWritten;
        // The amount of data read in the current heartbeat interval
        private long            bytesRead;
        // The number of keys written in the current heartbeat interval
        private long            keysWritten;
        // The number of keys read in the current heartbeat interval
        private long            keysRead;
        // The specific length of the heartbeat interval
        private TimeInterval    interval;
     }
</code></pre>

<ul>
<li>RegionHeartbeat</li>
</ul>

<pre><code class="language-java">  public class RegionStats implements Serializable {
        private long                regionId;
        // The region leader sends heartbeats
        private Peer                leader;
        // The list of offline peers
        private List&lt;PeerStats&gt;     downPeers;
        // Currently unavailable followers
        private List&lt;PeerStats&gt;     pendingPeers;
        // The amount of data written in the current heartbeat interval
        private long                bytesWritten;
        // The amount of data read in the current heartbeat interval
        private long                bytesRead;
        // The number of keys written in the current heartbeat interval
        private long                keysWritten;
        // The number of keys read in the current heartbeat interval
        private long                keysRead;
        // The (approximate) size of storage used by the region
        private long                approximateSize;
        // The (approximate) number of keys contained in the region
        private long                approximateKeys;
        // The specific length of the heartbeat interval
        private TimeInterval        interval;
    }
</code></pre></li>
</ul>

<h4 id="pipeline">Pipeline</h4>

<p>The computing and storage processing pipeline for states reported through heartbeats. The processing handlers are pluggable and are flexibly scalable.</p>

<h4 id="metadatastore">MetadataStore</h4>

<p>Responsible for storage and query of meta information of the cluster. The storage is based on the embedded RheaKV.</p>

<h3 id="client-routing">Client routing</h3>

<h4 id="sharding-logic-regionroutetable"><strong>Sharding logic: RegionRouteTable</strong></h4>

<p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*NySFTZrZ8l4AAAAAAAAAAABjARQnAQ" alt="Sharding logic" /></p>

<p>As you can see, the most suitable data structure to implement the logic shown in the above figure is the skip list or the binary tree (closest to the matching query).</p>

<p>We choose the key of the RegionRouteTable for some reason. Which should we use, the starKey or endKey of the region? Why don&rsquo;t we use the endKey? This is mainly determined by the region split method:</p>

<ul>
<li>Assume that region2 [startKey2, endKey2) splits.</li>
<li>It splits into two regions, region2 [startKey2, splitKey) and region3 [splitKey, endKey2).</li>
<li>Take another look at the above figure, you will understand that we only need to add one element <region3, splitKey> to the RegionRouteTable. Data of the original region2 does not need to be modified.

<ul>
<li><strong>Write operation</strong>

<ul>
<li>The routing logic of single-key<span data-type="color" style="color:rgb(38, 38, 38)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> write requests is very simple: query for the region based on the key, and initiate a request to the region.</span></span></li>
<li>A batch write request, for example __ __put(List), must perform the split operation on all keys, group them, and send parallel requests to their corresponding region engines. Note that transaction guarantee cannot be provided in this case.</li>
</ul></li>
<li><strong>Read operation</strong>

<ul>
<li>The routing logic of single-key read requests is very simple, too: <span data-type="color" style="color:rgb(38, 38, 38)"><span data-type="background" style="background-color:rgb(255, 255, 255)">query for the region based on the key, and initiate a request to the region.</span></span></li>
<li><span data-type="color" style="color:rgb(38, 38, 38)"><span data-type="background" style="background-color:rgb(255, 255, 255)">In the case of a batch read request, for example </span></span>scan(startKey, endKey),<span data-type="color" style="color:rgb(38, 38, 38)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> it needs to perform the split operation on all keys, group them, and send parallel requests to their corresponding region engines.</span></span></li>
</ul></li>
</ul></li>
</ul>

<h4 id="failover">Failover</h4>

<p><strong>RheaKV provides asynchronous APIs to clients, which means the failover process must also be asynchronous. It increases the design difficulty and implementation complexity.</strong></p>

<p><strong>RheaKV must solve the following problems:</strong></p>

<ol>
<li>Retry after asynchronous failure.</li>
<li>In the case of membership change, RheaKV must refresh the membership before retry.</li>
<li>In the case of automatic region split during the operation on multiple keys (for example range scan), RheaKV must also be able to automatically split (increase) the requests during a retry, and asynchronously combine multiple responses.</li>
<li>The previous operation may be a local call, but the retry may involve a remote call, or the other way around. These two cases must both be considered and supported.</li>
</ol>

<p><strong>RheaKV divides requests into two types, requiring different failover logic:</strong></p>

<ul>
<li><strong>Single-key operation requests (only one key)</strong>:
Retry depends on a callback class named FailoverClosure, the general logic of which is as follows:</li>
</ul>

<pre><code class="language-java">   public void run(final Status status) {
        if (status.isOk()) {
            // Success
            success((T) getData());
        } else if (this.retriesLeft &gt; 0 &amp;&amp;
                (isInvalidPeer(getError()) || (this.retryOnInvalidEpoch &amp;&amp; isInvalidEpoch(getError())))) {
            // Retry
            this.retryRunner.run(getError());
        } else {
            // Failure
            failure(getError());
        }
    }
</code></pre>

<p>Two types of errors (in Table 1 and Table 2) may trigger retryRunner. Before retryRunner is run, it first refreshes the region information and group peers (route table).</p>

<hr />

<p>Table 1</p>

<table>
<thead>
<tr>
<th align="left">NOT_LEADER</th>
<th align="left">The current node is not the leader.</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">NO_REGION_FOUND</td>
<td align="left">The specified region engine is not found on the current server.</td>
</tr>

<tr>
<td align="left">LEADER_NOT_AVAILABLE</td>
<td align="left">The current region group may have not elected a leader.</td>
</tr>
</tbody>
</table>

<hr />

<p>Table 2</p>

<table>
<thead>
<tr>
<th align="left">INVALID_REGION_MEMBERSHIP</th>
<th align="left">The current region group has undergone a membership change, for example a node is added or deleted.</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">INVALID_REGION_VERSION</td>
<td align="left">The current region has been split.</td>
</tr>

<tr>
<td align="left">INVALID_REGION_EPOCH</td>
<td align="left">It can either be INVALID_REGION_MEMBERSHIP or INVALID_REGION_VERSION.</td>
</tr>
</tbody>
</table>

<hr />

<ul>
<li><p><strong>Multi-Key operation requests (multiple keys or a key range)</strong></p>

<ol>
<li><p>For a multi-key request, split the keys first. Each region contains some of the keys, and has a separate failover process. In this case, the FailoverClosure class can only handle error types in table 1, and the processing logic is the same as that of <strong>single-key-operation requests</strong>.</p></li>

<li><p>The FailoverClosure class cannot handle the three errors listed in Table 2, because region split may have occurred upon epoch changes, which means the previous regions may have doubled. Now, the failover process has to not only request for the region information from the PD, but also deal with increased requests (requests increase with the regions). Therefore, a few <strong>failover futures</strong> are introduced to deal with the logic with increased requests.</p></li>

<li><p>The main logic of the failover future of <strong>scan(startKey, endKey)</strong> is as follows. You can see that the entire process is fully asynchronous.</p></li>
</ol>

<pre><code class="language-java">  @Override
   public boolean completeExceptionally(final Throwable ex) {
        if (this.retriesLeft &gt; 0 &amp;&amp; ApiExceptionHelper.isInvalidEpoch(ex)) {
            LOG.warn(&quot;[InvalidEpoch-Failover] cause: {}, [{}] retries left.&quot;, StackTraceUtil.stackTrace(ex),
                    this.retriesLeft);
     // Encounter invalid epoch, retry, may split requests, and then return the entire future group.
            final FutureGroup&lt;List&lt;T&gt;&gt; futureGroup = this.retryCallable.run(ex);
            CompletableFuture.allOf(futureGroup.toArray()).whenComplete((ignored, throwable) -&gt; {
                if (throwable == null) {
                    final List&lt;T&gt; all = Lists.newArrayList();
                    for (final CompletableFuture&lt;List&lt;T&gt;&gt; partOf : futureGroup.futures()) {
                        all.addAll(partOf.join());
                    }
                    // The entire future group is complete.
                    super.complete(all);
                } else {
                    // The exception handling is complete.
                    super.completeExceptionally(throwable);
                }
            });
            return false;
        }
        if (this.retriesLeft &lt;= 0) {
            LOG.error(&quot;[InvalidEpoch-Failover] cause: {}, {} retries left.&quot;, StackTraceUtil.stackTrace(ex),
                    this.retriesLeft);
        }
        // 0 retry attempts remain, or the current exception type does not require retries.
        return super.completeExceptionally(ex);
  }
</code></pre>

<h4 id="for-example-a-scan-procedure">For example: a scan procedure</h4>

<ul>
<li><strong>Determine the list of regions covered by the key range [startKey, endKey).</strong></li>
<li>RegionRouteTable#findRegionsByKeyRange(startKey, endKey)</li>
<li>RegionRouteTable is a region routing table stored in a red/black tree structure. startKey is used as the key of the red/black tree. Look for the sub-view of [startKey, endKey) and then add a floorEntry (startKey).</li>
<li>As shown in the following example, RheaKV works out that the range [startKey, endKey) crosses three regions: region1, region2, and region3 (region1 is the floor entry, and region2 and region3 are the sub-views).</li>
</ul>

<p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*5gBCRJZjEqAAAAAAAAAAAABjARQnAQ" alt="Region list" /></p>

<ul>
<li><strong>Request split: scan -&gt; multi-region scan</strong></li>
<li>region1 -&gt; regionScan(startKey, regionEndKey1)</li>
<li>region2 -&gt; regionScan(regionStartKey2, regionEndKey2)</li>
<li>region3 -&gt; regionScan(regionStartKey3, endKey)</li>
</ul>

<p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*BLVgSaFlAgoAAAAAAAAAAABjARQnAQ" alt="Request split" /></p>

<ul>
<li><strong>Encounter region split (the sign of split is region epoch change)</strong></li>
<li>Refresh RegionRouteTable, and get the latest route table from the PD. For example, region 2 in the following figure has been split into region 2 and region 5.

<ul>
<li>region2 -&gt; regnonScan(regionStartKey2, regionEndKey2) splits requests and retries

<ul>
<li>region2 -&gt; regionScan(regionStartKey2, newRegionEndKey2)</li>
<li>region5 -&gt; regionScan(regionStartKey5, regionEndKey5)</li>
</ul></li>
</ul></li>
</ul>

<p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*Cr5gT4FFs3QAAAAAAAAAAABjARQnAQ" alt="Region split" /></p>

<ul>
<li><strong>Encounter Invalid Peer (errors such as NOT_LEADER)</strong></li>
<li>This is simple. It requests for the information of the latest leader of the Raft group of the current key range, and initiates calls again.</li>
</ul></li>
</ul>

</article>

<script>
  const article = document.querySelector('article.typo')
  
  const imgElements = article.querySelectorAll('img');
  
  imgElements.forEach(img => {
    const src = img.getAttribute('src');
    
    if (src.toLowerCase().endsWith('.image')) {
      img.setAttribute('src', src.replace('.image', ''));
    }
    img.setAttribute('referrerpolicy', 'no-referrer');
  });
</script>


	</main>
</div>



	


<footer class="ss-footer">
	<div class="container">
		<div class="links">
			
				<div class="cate">
					<h2 class="cate-title">Resources</h2>
					
						<a class="link" href="https://github.com/sofastack">Github</a>
					
						<a class="link" href="https://gitee.com/sofastack/">Gitee</a>
					
						<a class="link" href="https://github.com/sofastack-guides">Samples</a>
					
				</div>
			
				<div class="cate">
					<h2 class="cate-title">Social Media</h2>
					
						<a class="link" href="https://zhuanlan.zhihu.com/sofastack">Zhihu</a>
					
						<a class="link" href="https://weibo.com/sofastack">Weibo</a>
					
						<a class="link" href="https://twitter.com/sofastack_io">Twitter</a>
					
				</div>
			
				<div class="cate">
					<h2 class="cate-title">Get Involved</h2>
					
						<a class="link" href="https://github.com/sofastack/sofastack.tech/issues">Feedback</a>
					
						<a class="link" href="https://github.com/sofastack/community">Community</a>
					
						<a class="link" href="https://github.com/sofastack/sofastack.tech/wiki">Wiki</a>
					
						<a class="link" href="mailto:sofa@alipay.cloud.com">Email</a>
					
				</div>
			
				<div class="cate">
					<h2 class="cate-title">Ant Financial Open Source</h2>
					
						<a class="link" href="https://ant.design/">Ant Design</a>
					
						<a class="link" href="https://eggjs.org/">Egg</a>
					
						<a class="link" href="https://sqlflow.org">SQLFlow</a>
					
						<a class="link" href="https://tech.antfin.com/open-source">More</a>
					
				</div>
			
		</div>
		<div class="qrcode">
			
				<div>
					<img class="qrcode-img" src="/sofastack.tech/img/qrcode/qrcode_1.png" />
					<p class="qrcode-desc">Wechat Official Account</p>
				</div>
			
				<div>
					<img class="qrcode-img" src="/sofastack.tech/img/qrcode/qrcode_2.png" />
					<p class="qrcode-desc">DingTalk Group</p>
				</div>
			
		</div>
	</div>
	<div class="copyright">
		<p>
			© 2018 - 2022  The SOFAStack Authors
			<a href="http://beian.miit.gov.cn/">浙 ICP 备 16045294 号-3</a>
		</p>
	</div>
</footer>

</body>

</html>