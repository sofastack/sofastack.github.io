<!DOCTYPE html>
<html>

<head>
	<title>
	JRaft RheaKV 用户指南 · SOFAStack
</title>
	<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="SOFAStack is a Scalable Open Financial Architecture for building cloud native applications" />

<meta name="generator" content="Hugo 0.55.5" /><link rel="shortcut icon" href=https://gw.alipayobjects.com/os/q/cms/images/jqu9346l/4ba95631-2489-4885-881f-bc7f8d787d5e_w64_h61.png type="image/png">

<link href="https://unpkg.com/purecss@1.0.0/build/base-min.css" rel="stylesheet">



<link href="/sofastack.tech/css/main.css" rel="stylesheet">
<link href="/sofastack.tech/css/zoom-image.css" rel="stylesheet">

<script src="/sofastack.tech/js/iconfont.js"></script>
<script src="/sofastack.tech/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<script>window.SITE_LANGUAGE = "zh"</script>
<script src="/sofastack.tech/js/app.js"></script>





<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-142131411-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</head>

<body>
	<header class="ss-header">
	<nav class="navbar" role="navigation" aria-label="main navigation">
		<div class="navbar-brand">
			<a class="logo-link" href="/sofastack.tech/">
				<img class="logo" src="/sofastack.tech/img/logo.png">
			</a>
			<div class="-show-mobile">
				<a id="mobile-menu-icon">
					<svg class="icon" aria-hidden="true">
						<use xlink:href="#icon-menu"></use>
					</svg>
				</a>
				<nav id="mobile-menu">
						<div id="js-menu-search-mobile" class="navbar-search-mobile">
							<input class="input" placeholder="请输入要搜索的关键词">
							<svg class="icon" aria-hidden="true">
								<use xlink:href="#icon-search"></use>
							</svg>
						</div>
					
          
            <a
              class=""
              href="/sofastack.tech/projects/">
              <span>
                项目
              </span>
              <svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"></use></svg>
            </a>
					
            <a
              class=""
              href="/sofastack.tech/guides/">
              <span>
                指南
              </span>
              <svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"></use></svg>
            </a>
					
            <a
              class=""
              href="/sofastack.tech/blog/">
              <span>
                博客
              </span>
              <svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"></use></svg>
            </a>
					
            <a
              class=""
              href="/sofastack.tech/activities/">
              <span>
                活动
              </span>
              <svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"></use></svg>
            </a>
					
            <a
              class=""
              href="/sofastack.tech/community/">
              <span>
                社区
              </span>
              <svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"></use></svg>
            </a>
					
            <a
              class=""
              href="/sofastack.tech/awesome/">
              <span>
                Awesome SOFA
              </span>
              <svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"></use></svg>
            </a>
					
					
            
              <a href="/sofastack.tech/en/projects/sofa-jraft/jraft-rheakv-user-guide/">
                <span>English</span>
                <svg class="icon" aria-hidden="true"><use xlink:href="#icon-transfer"></use></svg>
              </a>
						
					
				</nav>
			</div>
		</div>

		<div class="navbar-menu -hidden-mobile">
			<div class="navbar-start">
				
				
					<a class="navbar-item "
						href="/sofastack.tech/projects/">项目</a>
				
					<a class="navbar-item "
						href="/sofastack.tech/guides/">指南</a>
				
					<a class="navbar-item "
						href="/sofastack.tech/blog/">博客</a>
				
					<a class="navbar-item "
						href="/sofastack.tech/activities/">活动</a>
				
					<a class="navbar-item "
						href="/sofastack.tech/community/">社区</a>
				
					<a class="navbar-item "
						href="/sofastack.tech/awesome/">Awesome SOFA</a>
				
			</div>
			<div class="navbar-end">
				<div class="navbar-item">
					<div id="js-menu-search" class="navbar-search">
						<input class="input" placeholder="请输入要搜索的关键词">
						<svg class="icon" aria-hidden="true">
							<use xlink:href="#icon-search"></use>
						</svg>
					</div>
				</div>
				<div class="navbar-item">
					
						
							<a class="translation" href="/sofastack.tech/en/projects/sofa-jraft/jraft-rheakv-user-guide/">En</a>
						
					
				</div>
			</div>
		</div>
	</nav>
</header>


	

	

	

	

	

	



	

<div class="ss-layout-container">
	<aside class="ss-layout-aside -left ss-card -soft-hidden">
		






	<div id="js-drawer" class="ss-toc">
		<div id="js-drawer-handle" class="drawer-handle">
			<svg class="icon icon-menu" aria-hidden="true">
				<use xlink:href="#icon-menu"></use>
			</svg>
			<svg class="icon icon-close" aria-hidden="true">
				<use xlink:href="#icon-close"></use>
			</svg>
		</div>
		<div class="drawer-body">
			<div class="header" title="SOFAJRaft 是一个基于 RAFT 一致性算法的生产级高性能 Java 实现，支持 MULTI-RAFT-GROUP，适用于高负载低延迟的场景。">SOFAJRaft



























































































































































































































































































































































































































































































































































































<div class="ss-toc-list-card -hidden-mobile">
	<svg class="icon -hidden-mobile" aria-hidden="true">
		<use xlink:href="#icon-menu1"></use>
	</svg>
	<div class="ss-tooltip">
		
		
		<div class="toc-list">
			<h4 class="title">主要项目</h4>
			<ul class="list">
				
				<li class="item">
					
					
					
					
					<a href=/sofastack.tech/projects/sofa-boot/overview/>
						SOFABoot
					</a>
				</li>
				
				<li class="item">
					
					
					
					
					<a href=/sofastack.tech/projects/sofa-rpc/overview/>
						SOFARPC
					</a>
				</li>
				
				<li class="item">
					
					
					
					
					<a href=/sofastack.tech/projects/sofa-tracer/overview/>
						SOFATracer
					</a>
				</li>
				
				<li class="item">
					
					
					
					
					<a href=/sofastack.tech/projects/sofa-lookout/overview/>
						SOFALookout
					</a>
				</li>
				
				<li class="item">
					
					
					
					
					<a href=/sofastack.tech/projects/sofa-registry/overview/>
						SOFARegistry
					</a>
				</li>
				
			</ul>
		</div>
		
		
		
		<div class="toc-list">
			<h4 class="title">孵化项目</h4>
			<ul class="list">
				
				<li class="item">
					
					
					
					
					<a href=/sofastack.tech/projects/sofa-mesh/overview/>
						SOFAMesh
					</a>
				</li>
				
				<li class="item">
					
					
					
					
					<a href=/sofastack.tech/projects/sofa-dashboard/overview/>
						SOFADashboard
					</a>
				</li>
				
			</ul>
		</div>
		
		
		
		<div class="toc-list">
			<h4 class="title">工具项目</h4>
			<ul class="list">
				
				<li class="item">
					
					
					
					
					<a href=/sofastack.tech/projects/sofa-bolt/overview/>
						SOFABolt
					</a>
				</li>
				
				<li class="item">
					
					
					
					
					<a href=/sofastack.tech/projects/sofa-jraft/overview/>
						SOFAJRaft
					</a>
				</li>
				
				<li class="item">
					
					
					
					
					<a href=/sofastack.tech/projects/sofa-acts/overview/>
						SOFAActs
					</a>
				</li>
				
				<li class="item">
					
					
					
					
					
					
					<a href=https://www.sofastack.tech/projects/sofa-boot/sofa-ark-readme//>
						SOFAArk
					</a>
				</li>
				
			</ul>
		</div>
		
		
		
		<div class="toc-list">
			<h4 class="title">生态项目</h4>
			<ul class="list">
				
				<li class="item">
					
					
					
					
					
					
					<a href=https://mosn.io/>
						MOSN
					</a>
				</li>
				
				<li class="item">
					
					
					
					
					
					
					<a href=https://occlum.io/>
						Occlum
					</a>
				</li>
				
				<li class="item">
					
					
					
					
					
					
					<a href=https://seata.io/>
						Seata
					</a>
				</li>
				
				<li class="item">
					
					
					
					
					
					
					<a href=https://mosn.io/layotto/>
						Layotto
					</a>
				</li>
				
			</ul>
		</div>
		
		
	</div>
</div>

			</div>
			<div class="body">
				



<ul class="leaf-section">
	
		
			<li class="item">
				<div class="link">
					<a
						title="SOFAJRaft 介绍"
						href="/sofastack.tech/projects/sofa-jraft/overview/"
					>SOFAJRaft 介绍</a>
				</div>
			</li>
		
		
	
		
			<li class="item">
				<div class="link">
					<a
						title="核心引擎设计"
						href="/sofastack.tech/projects/sofa-jraft/engine-architecture/"
					>核心引擎设计</a>
				</div>
			</li>
		
		
	
		
			<li class="item">
				<div class="link">
					<a
						title="Jepsen 验证"
						href="/sofastack.tech/projects/sofa-jraft/jepson-test/"
					>Jepsen 验证</a>
				</div>
			</li>
		
		
	
		
		
			<li class="item">
				<div class="link">
					<svg class="icon arrow" aria-hidden="true">
						<use xlink:href="#icon-arrow"></use>
					</svg>
					<a
						title="用户指南"
					>用户指南</a>
				</div>
				



<ul class="leaf-section">
	
		
			<li class="item">
				<div class="link">
					<a
						title="JRaft 用户指南"
						href="/sofastack.tech/projects/sofa-jraft/jraft-user-guide/"
					>JRaft 用户指南</a>
				</div>
			</li>
		
		
	
		
			<li class="item">
				<div class="link -current">
					<a
						title="JRaft RheaKV 用户指南"
						href="/sofastack.tech/projects/sofa-jraft/jraft-rheakv-user-guide/"
					>JRaft RheaKV 用户指南</a>
				</div>
			</li>
		
		
	
		
			<li class="item">
				<div class="link">
					<a
						title="Counter 例子详解"
						href="/sofastack.tech/projects/sofa-jraft/counter-example/"
					>Counter 例子详解</a>
				</div>
			</li>
		
		
	
</ul>
			</li>
		
	
		
			<li class="item">
				<div class="link">
					<a
						title="Maven 依赖说明"
						href="/sofastack.tech/projects/sofa-jraft/maven-dependency/"
					>Maven 依赖说明</a>
				</div>
			</li>
		
		
	
		
			<li class="item">
				<div class="link">
					<a
						title="版本发行日志"
						href="/sofastack.tech/projects/sofa-jraft/release-log/"
					>版本发行日志</a>
				</div>
			</li>
		
		
	
		
			<li class="item">
				<div class="link">
					<a
						title="Benchmark 数据"
						href="/sofastack.tech/projects/sofa-jraft/benchmark-performance/"
					>Benchmark 数据</a>
				</div>
			</li>
		
		
	
		
			<li class="item">
				<div class="link">
					<a
						title="用户案例"
						href="/sofastack.tech/projects/sofa-jraft/user-stories/"
					>用户案例</a>
				</div>
			</li>
		
		
	
		
			<li class="item">
				<div class="link">
					<a
						title="Road map"
						href="/sofastack.tech/projects/sofa-jraft/road-map/"
					>Road map</a>
				</div>
			</li>
		
		
	
		
		
			<li class="item">
				<div class="link">
					<svg class="icon arrow" aria-hidden="true">
						<use xlink:href="#icon-arrow"></use>
					</svg>
					<a
						title="扩展资料"
					>扩展资料</a>
				</div>
				



<ul class="leaf-section">
	
		
			<li class="item">
				<div class="link">
					<a
						title="Raft 算法解读"
						href="/sofastack.tech/projects/sofa-jraft/raft-introduction/"
					>Raft 算法解读</a>
				</div>
			</li>
		
		
	
		
			<li class="item">
				<div class="link">
					<a
						title="分布式一致性 - Raft 与 JRaft"
						href="/sofastack.tech/projects/sofa-jraft/consistency-raft-jraft/"
					>分布式一致性 - Raft 与 JRaft</a>
				</div>
			</li>
		
		
	
</ul>
			</li>
		
	
		
		
			<li class="item">
				<div class="link">
					<svg class="icon arrow" aria-hidden="true">
						<use xlink:href="#icon-arrow"></use>
					</svg>
					<a
						title="其他"
					>其他</a>
				</div>
				



<ul class="leaf-section">
	
		
			<li class="item">
				<div class="link">
					<a
						title="如何参与 SOFAJRaft 代码贡献"
						href="/sofastack.tech/projects/sofa-jraft/how-to-contribute-code-to-sofajraft/"
					>如何参与 SOFAJRaft 代码贡献</a>
				</div>
			</li>
		
		
	
</ul>
			</li>
		
	
</ul>
			</div>
		</div>
	</div>

	</aside>

	<main class="ss-layout-main -card">
		




<div class="ss-meta">
	<div class="container">
		<h1 class="title">
			JRaft RheaKV 用户指南
		</h1>
		<a class="edit-button -hidden-mobile"
			href="https://github.com/sofastack/sofastack.tech/edit/master/content/zh/projects/sofa-jraft/jraft-rheakv-user-guide/index.md"
		>编辑</a>
	</div>
	<div class="meta">
		更新时间: 2024-06-18 
		
			
		
	</div>
</div>

		<article class="typo">
  <p>RheaKV 是一个轻量级的分布式的嵌入式的 KV 存储 lib， rheaKV 包含在 jraft 项目中，是 jraft 的一个子模块。</p>

<p><strong>定位与特性</strong></p>

<ol>
<li>嵌入式: jar 包方式嵌入到应用中</li>
<li>强一致性: 基于 multi-raft 分布式一致性协议保证数据可靠性和一致性</li>
<li>自驱动 （目前未完全实现）: 自诊断, 自优化, 自决策, 自恢复</li>
<li>可监控: 基于节点自动上报到PD的元信息和状态信息</li>
<li>基本API: get/put/delete 和跨分区 scan/batch put, distributed lock 等等</li>
</ol>

<h2 id="架构设计">架构设计</h2>

<p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*6K1mTq0z-TkAAAAAAAAAAABjARQnAQ" alt="架构设计" /></p>

<h2 id="功能名词">功能名词</h2>

<ul>
<li>PD: 全局的中心总控节点，负责整个集群的调度，一个 PD server 可以管理多个集群，集群之间基于 clusterId 隔离；PD server 需要单独部署，当然，很多场景其实并不需要自管理，rheaKV 也支持不启用 PD</li>
<li>Store: 集群中的一个物理存储节点，一个 store 包含一个或多个 region</li>
<li>Region: 最小的 KV 数据单元，可理解为一个数据分区或者分片，每个 region 都有一个左闭右开的区间 [startKey, endKey)</li>
</ul>

<h2 id="存储设计">存储设计</h2>

<ul>
<li>存储层为可插拔设计， 目前支持 MemoryDB 和 RocksDB 两种实现：

<ul>
<li>MemoryDB 基于 ConcurrentSkipListMap 实现，有更好的性能，但是单机存储容量受内存限制</li>
<li><a href="https://github.com/facebook/rocksdb">RocksDB</a> 在存储容量上只受磁盘限制，适合更大数据量的场景</li>
</ul></li>
<li>数据强一致性， 依靠 jraft 来同步数据到其他副本, 每个数据变更都会落地为一条 raft 日志, 通过 raft 的日志复制功能, 将数据安全可靠地同步到同 group 的全部节点中</li>
</ul>

<h2 id="使用场景">使用场景</h2>

<ul>
<li>轻量级的状态/元信息存储以及集群同步</li>
<li>分布式锁服务</li>
</ul>

<h2 id="api-说明">API 说明</h2>

<p>整体上 rheaKV apis 分为异步和同步两类， 其中以 b （block）开头的方法均为同步阻塞方法， 其他为异步方法，异步方法均返回一个 <code>CompletableFuture</code>，对于 read method， 还有一个重要参数 readOnlySafe，为 true 时表示提供线性一致读， 不包含该参数的 read method 均为默认提供线性一致读</p>

<h3 id="get">get</h3>

<pre><code class="language-java">CompletableFuture&lt;byte[]&gt; get(final byte[] key);
CompletableFuture&lt;byte[]&gt; get(final String key);
CompletableFuture&lt;byte[]&gt; get(final byte[] key, final boolean readOnlySafe);
CompletableFuture&lt;byte[]&gt; get(final String key, final boolean readOnlySafe);
byte[] bGet(final byte[] key);
byte[] bGet(final String key);
byte[] bGet(final byte[] key, final boolean readOnlySafe);
byte[] bGet(final String key, final boolean readOnlySafe);
</code></pre>

<ol>
<li>String 类型入参，rheaKV 内部提供了更高效的 Utf8String encoder/decoder， 业务 key 为 String 时， 推荐的做法是直接使用 String 参数的接口</li>
<li>不需要线性一致读语义的场景可以将 readOnlySafe 设置为 false， 负载均衡器会优先选择本地调用，本地不能提供服务则轮询选择一台远程机器发起读请求</li>
</ol>

<h3 id="multiget">multiGet</h3>

<pre><code class="language-java">CompletableFuture&lt;Map&lt;ByteArray, byte[]&gt;&gt; multiGet(final List&lt;byte[]&gt; keys);
CompletableFuture&lt;Map&lt;ByteArray, byte[]&gt;&gt; multiGet(final List&lt;byte[]&gt; keys, final boolean readOnlySafe);
Map&lt;ByteArray, byte[]&gt; bMultiGet(final List&lt;byte[]&gt; keys);
Map&lt;ByteArray, byte[]&gt; bMultiGet(final List&lt;byte[]&gt; keys, final boolean readOnlySafe);
</code></pre>

<ol>
<li>multiGet 支持跨分区查询，rheaKV 内部会自动计算每个 key 的所属分区（region）并行发起调用， 最后合并查询结果</li>
<li>为了可以将 byte[] 放进 HashMap，这里曲线救国，返回值中 Map 的 key 为 ByteArray 对象，是对 byte[] 的一层包装，实现了 byte[] 的 hashCode</li>
</ol>

<h3 id="scan-iterator">scan &amp; iterator</h3>

<pre><code class="language-java">CompletableFuture&lt;List&lt;KVEntry&gt;&gt; scan(final byte[] startKey, final byte[] endKey);
CompletableFuture&lt;List&lt;KVEntry&gt;&gt; scan(final String startKey, final String endKey);
CompletableFuture&lt;List&lt;KVEntry&gt;&gt; scan(final byte[] startKey, final byte[] endKey, final boolean readOnlySafe);
CompletableFuture&lt;List&lt;KVEntry&gt;&gt; scan(final String startKey, final String endKey, final boolean readOnlySafe);
List&lt;KVEntry&gt; bScan(final byte[] startKey, final byte[] endKey);
List&lt;KVEntry&gt; bScan(final String startKey, final String endKey);
List&lt;KVEntry&gt; bScan(final byte[] startKey, final byte[] endKey, final boolean readOnlySafe);
List&lt;KVEntry&gt; bScan(final String startKey, final String endKey, final boolean readOnlySafe);

RheaIterator&lt;KVEntry&gt; iterator(final byte[] startKey, final byte[] endKey, final int bufSize);
RheaIterator&lt;KVEntry&gt; iterator(final String startKey, final String endKey, final int bufSize);
RheaIterator&lt;KVEntry&gt; iterator(final byte[] startKey, final byte[] endKey, final int bufSize, final boolean readOnlySafe);
RheaIterator&lt;KVEntry&gt; iterator(final String startKey, final String endKey, final int bufSize, final boolean readOnlySafe);
</code></pre>

<ol>
<li>scan 和 iterator 都会包含两个入参 <code>startKey</code>， <code>endKey</code>，范围是一个左闭右开的区间： <code>[startKey, endKey)</code></li>
<li>iterator 与 scan 的不同点在于 iterator 是懒汉模式，在调用 <code>hasNext()</code> 时如果本地缓冲区无数据 （bufSize 为缓冲区大小）才会触发请求数据操作</li>
<li>支持跨分区扫描，rheaKV 内部会自动计算 <code>startKey</code> ~ <code>endKey</code> 所覆盖的所有分区（region），并行发起调用， 对于单个分片数据量较大的情况，扫描整个分区一定是很慢的， 一定注意避免跨过多的分区</li>
<li><code>startKey</code> 可以为 null， 代表 minStartKey， 同理 <code>endKey</code> 也可以为 null，代表 maxEndKey，但如上一条所说，应尽量避免大范围的查询行为</li>
</ol>

<h3 id="getsequence-resetsequence">getSequence &amp; resetSequence</h3>

<pre><code class="language-java">// 获取
CompletableFuture&lt;Sequence&gt; getSequence(final byte[] seqKey, final int step);
CompletableFuture&lt;Sequence&gt; getSequence(final String seqKey, final int step);
Sequence bGetSequence(final byte[] seqKey, final int step);
Sequence bGetSequence(final String seqKey, final int step);
// 重置
CompletableFuture&lt;Boolean&gt; resetSequence(final byte[] seqKey);
CompletableFuture&lt;Boolean&gt; resetSequence(final String seqKey);
Boolean bResetSequence(final byte[] seqKey);
Boolean bResetSequence(final String seqKey);
</code></pre>

<ol>
<li>通过 <code>getSequence</code> 可以获取一个全局的单调递增序列，step 作为步长， 比如一个 step 为 10 的请求结果为 [n, n + 10)， 结果是一个左闭右开的区间，对于 sequence 的存储，是与普通 key-value 数据隔离的，所以无法使用普通 api 删除之， 所以不用担心 sequence 数据被误删除， 但是也提供了手动重置 sequence 的方法，见下一条说明</li>
<li>需要强调的是，通常是不建议使用 <code>resetSequence</code> 系列方法的，提供这个 api 只是为了用于一些意外场景的 sequence 重置</li>
</ol>

<h3 id="put">put</h3>

<pre><code class="language-java">CompletableFuture&lt;Boolean&gt; put(final byte[] key, final byte[] value);
CompletableFuture&lt;Boolean&gt; put(final String key, final byte[] value);
Boolean bPut(final byte[] key, final byte[] value);
Boolean bPut(final String key, final byte[] value);
</code></pre>

<ol>
<li>这个不做过多解释了，任何 kv 系统都会提供的 api，对于 String 类型的入参，请参考 get 相关说明。</li>
</ol>

<h3 id="getandput">getAndPut</h3>

<pre><code class="language-java">CompletableFuture&lt;byte[]&gt; getAndPut(final byte[] key, final byte[] value);
CompletableFuture&lt;byte[]&gt; getAndPut(final String key, final byte[] value);
byte[] bGetAndPut(final byte[] key, final byte[] value);
byte[] bGetAndPut(final String key, final byte[] value);
</code></pre>

<ol>
<li>提供一个原子的 &lsquo;get 旧值并 put 新值&rsquo; 的语义,  对于 String 类型的入参，请参考 get 相关说明。</li>
</ol>

<h3 id="compareandput">compareAndPut</h3>

<pre><code class="language-java">CompletableFuture&lt;Boolean&gt; compareAndPut(final byte[] key, final byte[] expect, final byte[] update);
CompletableFuture&lt;Boolean&gt; compareAndPut(final String key, final byte[] expect, final byte[] update);
Boolean bCompareAndPut(final byte[] key, final byte[] expect, final byte[] update);
Boolean bCompareAndPut(final String key, final byte[] expect, final byte[] update);
</code></pre>

<ol>
<li>提供一个原子的 &lsquo;compare 旧值并 put 新值&rsquo; 的语义, 其中 compare 语义表示 equals 而不是 ==。 对于 String 类型的入参，请参考 get 相关说明。</li>
</ol>

<h3 id="merge">merge</h3>

<pre><code class="language-java">CompletableFuture&lt;Boolean&gt; merge(final String key, final String value);
Boolean bMerge(final String key, final String value);
</code></pre>

<ol>
<li>目前只支持 String 类型的操作</li>
<li>提供一个原子的 merge 操作, 代替某些先 get 再 put 的场景, 效果见下面代码:</li>
</ol>

<pre><code class="language-java">// Writing aa under key
db.put(&quot;key&quot;, &quot;aa&quot;);
// Writing bb under key
db.merge(&quot;key&quot;, &quot;bb&quot;);
    
assertThat(db.get(&quot;key&quot;)).isEqualTo(&quot;aa,bb&quot;);
</code></pre>

<h3 id="batch-put">batch put</h3>

<pre><code class="language-java">CompletableFuture&lt;Boolean&gt; put(final List&lt;KVEntry&gt; entries);
boolean bPut(final List&lt;KVEntry&gt; entries);
</code></pre>

<ol>
<li>支持跨分区操作的一个 batch put, rheakv 内部会自动计算每个 key 的所属分区并行发起调用</li>
<li>需要注意的是， 这个操作暂时无法提供事务保证，无法承诺 ‘要么全部成功要么全部失败’，不过由于 rheaKV 内部是支持 failover 自动重试的， 可以一定程度上减少上述情况的发生</li>
</ol>

<h3 id="putifabsent">putIfAbsent</h3>

<pre><code class="language-java">CompletableFuture&lt;byte[]&gt; putIfAbsent(final byte[] key, final byte[] value);
CompletableFuture&lt;byte[]&gt; putIfAbsent(final String key, final byte[] value);
byte[] bPutIfAbsent(final byte[] key, final byte[] value);
byte[] bPutIfAbsent(final String key, final byte[] value);
</code></pre>

<ol>
<li>提供一种原子语义： 如果该 key 不存在则 put 如果该 key 已经存在， 那么只返回这个已存在的值</li>
</ol>

<h3 id="delete">delete</h3>

<pre><code class="language-java">CompletableFuture&lt;Boolean&gt; delete(final byte[] key);
CompletableFuture&lt;Boolean&gt; delete(final String key);
Boolean bDelete(final byte[] key);
Boolean bDelete(final String key);
</code></pre>

<ol>
<li>删除指定 key 关联的值</li>
</ol>

<h3 id="deleterange">deleteRange</h3>

<pre><code class="language-java">CompletableFuture&lt;Boolean&gt; deleteRange(final byte[] startKey, final byte[] endKey);
CompletableFuture&lt;Boolean&gt; deleteRange(final String startKey, final String endKey);
boolean bDeleteRange(final byte[] startKey, final byte[] endKey);
boolean bDeleteRange(final String startKey, final String endKey);
</code></pre>

<ol>
<li>移除 <code>[startKey, endKey)</code> 范围内所有的数据， 注意 key的 范围是一个左闭右开的区间，即不包含<code>endKey</code></li>
<li>同样支持跨分区删除， rheaKV 内部会自动计算这个 key 区间的所覆盖的分区然后并行发起调用， 同样需要强调，这是个较危险的操作，请慎重使用</li>
</ol>

<h3 id="execute">execute</h3>

<pre><code class="language-java">CompletableFuture&lt;Boolean&gt; execute(final long regionId, final NodeExecutor executor);
Boolean bExecute(final long regionId, final NodeExecutor executor);
</code></pre>

<ol>
<li>唯一一个跟存储无关的接口, NodeExecutor 可以执行一些操作（比如更新当前节点的缓存），调用这个 api 能保证最终集群中所有节点都会执行这个 executor</li>
<li>这个 api 没有直接在 RheaKVStore 中开放，确实有类似使用场景的需要强转 <code>DefaultRheaKVStore</code></li>
</ol>

<h3 id="distributedlock">DistributedLock</h3>

<pre><code class="language-java">DistributedLock&lt;byte[]&gt; getDistributedLock(final byte[] target, final long lease, final TimeUnit unit);
DistributedLock&lt;byte[]&gt; getDistributedLock(final String target, final long lease, final TimeUnit unit);
DistributedLock&lt;byte[]&gt; getDistributedLock(final byte[] target, final long lease, final TimeUnit unit,
                                           final ScheduledExecutorService watchdog);
DistributedLock&lt;byte[]&gt; getDistributedLock(final String target, final long lease, final TimeUnit unit,
                                           final ScheduledExecutorService watchdog);
</code></pre>

<ol>
<li>获取一个分布式锁实例，rheaKV 的 distributedLock 实现了: 可重入锁、自动续租以及 fencing token</li>
<li>target：可以为理解为分布式锁的 key, 不同锁的 key 不能重复，但是锁的存储空间是与其他 kv 数据隔离的，所以只需保证 key 在 &lsquo;锁空间&rsquo; 内的唯一性即可</li>
<li>lease：必须包含一个锁的租约（lease）时间，在锁到期之前，如果 watchdog 为空，那么锁会被自动释放，即没有 watchdog 配合的 lease，就是 timeout 的意思</li>
<li>watchdog：一个自动续租的调度器，需要用户自行创建并销毁，框架内部不负责该调度器的生命周期管理，如果 watchdog 不为空，会定期（lease 的 <sup>2</sup>&frasl;<sub>3</sub> 时间为周期）主动为当前的锁不断进行续租，直到用户主动释放锁（unlock）</li>
<li>还有一个需要强调的是：因为 distributedLock 是可重入锁，所以 <code>lock()</code> 与 <code>unlock()</code> 必须成对出现，比如 <code>lock()</code> 2 次却只 <code>unlock()</code> 1 次是无法释放锁成功的</li>
<li>String 类型入参: 见 get 相关说明</li>
<li>其中 <code>boolean tryLock(final byte[] ctx)</code> 包含一个 ctx 入参， 作为当前的锁请求者的用户自定义上下文数据，如果它成功获取到锁，其他线程、进程也可以看得到它的 ctx</li>
<li>一个简单的使用例子见下面伪代码:</li>
</ol>

<pre><code class="language-java">    DistributedLock&lt;T&gt; lock = ...;
    if (lock.tryLock()) {
        try {
            // manipulate protected state
        } finally {
            lock.unlock();
        }
    } else {
        // perform alternative actions
    }
</code></pre>

<p><strong>Note</strong>: 还有一个重要的方法 <code>long getFencingToken()</code>，当成功上锁后，可以通过该接口获取当前的 fencing token， 这是一个单调递增的数字，也就是说它的值大小可以代表锁拥有者们先来后到的顺序，可以用这个 fencing token 解决下图<a href="http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">这个问题</a>：</p>

<p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*ZKq8SrSGE90AAAAAAAAAAABjARQnAQ" alt="分布式锁" /></p>

<p>上图来自 <a href="http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html</a></p>

<h2 id="快速开始">快速开始</h2>

<h3 id="启动yaml配置">启动yaml配置</h3>

<pre><code class="language-yaml">##RheaKVStoreOptions
---
# 与PD连接需要一个 clusterId, PD 依靠 clusterId 来隔离不同业务, 无 PD 模式不需要配置
clusterId: 1
# 每个 store 节点包含一个或多个 raft-group 复制组, 这个字段是所有复制组的名称前缀, 所有的 raft-group name 遵循
# [clusterName-regionId]的命名规则
clusterName: rhea_test

# PD 相关选项设置
placementDriverOptions:
# fake==true 表示在无 PD 模式下启动, 无 PD 模式将失去&quot;自管理&quot;能力, 所有设置都基于当前这个初始的配置文件
  fake: true

# store存储节点的相关选项设置
storeEngineOptions:
  rocksDBOptions:
# 是否同步刷盘, 默认为 true, 异步刷盘性能更好, 但是在机器掉电时有丢数据风险
    sync: true
# kv数据存储目录
    dbPath: rhea_db/
  # raft log存储目录
  raftDataPath: rhea_raft/
  serverAddress:
# 本机地址, 默认自动获取本机host name, 也可以自己设置
    ip: 127.0.0.1
# 端口, 这个是必须配置的选项, 存储层提供rpc服务的监听端口
    port: 8181

# 集群列表中所有节点的地址列表
initialServerList: 127.0.0.1:8181,127.0.0.1:8182,127.0.0.1:8183

# 是否只从 leader 节点读取数据, 默认为true, 当然从follower节点读也能保证线性一致读, 但是如果一个 follower 节点在同步数据时落后较多的情况下
# 将导致读请求超时, 从而导致 rheaKV 客户端 failover 逻辑启动重新从 leader 节点上尝试读取, 最终结果就是读请求延时较长
onlyLeaderRead: true

# RPC组件相关选项设置
# rpcOptions:

# 失败重试次数
failoverRetries: 2
</code></pre>

<h3 id="启动代码">启动代码</h3>

<pre><code class="language-java">final ObjectMapper mapper = new ObjectMapper(new YAMLFactory());
final RheaKVStoreOptions opts = mapper.readValue(new File(&quot;rheakv_conf&quot;), RheaKVStoreOptions.class);
final RheaKVStore rheaKVStore = new DefaultRheaKVStore();
if (rheaKVStore.init(opts)) {
    rheaKVStore.bPut(&quot;hello&quot;, &quot;hello world!!!&quot;)
    byte[] bytesVal = rheaKVStore.get(&quot;hello&quot;);
    System.out.println(new String(bytesVal);
    // ...
    // Have fun !!!
}
</code></pre>

<p>除了基于 yaml 配置启动，rheaKV 也提供了一系列 XXXConfigured 类来方便设置 rheaKV 的配置参数，具体 example 可以参考 jraft-example 模块中的 demo</p>

<h2 id="核心设计">核心设计</h2>

<h3 id="kv模块内部处理流程">KV模块内部处理流程</h3>

<p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*VsIgSqmCSQUAAAAAAAAAAABjARQnAQ" alt="KV 模块内部处理流程" /></p>

<h4 id="rheakvstore">RheaKVStore</h4>

<p>最上层 User API，默认实现为 DefaultRheaKVStore， RheaKVStore 为纯异步实现，所以通常阻塞调用导致的客户端出现瓶颈，理论上不会在RheaKV上遭遇，DefaultRheaKVStore 实现了包括请求路由、request 分裂、response 聚合以及失败重试等功能</p>

<h4 id="placementdriverclient">PlacementDriverClient</h4>

<p>非必须，作为与 PlacementDriver Server 集群沟通的客户端，可以通过它获取集群完整信息，包括但不仅限于&rdquo;请求路由表&rdquo;，对于无 PD 场景， rheaKV 提供一个 fake pd client</p>

<h4 id="regionroutetable">RegionRouteTable</h4>

<p>作为一个本地路由表缓存组件，RegionRouteTable 会根据 kv 请求的具体失败原因来决策是否从 PD Server 集群刷新数据，还提供对单个 key、多个 key 列表以及一个key range进行计算，返回对应的分区 ID</p>

<h4 id="loadbalancer">LoadBalancer</h4>

<p>在提供 follower 线性一致读的配置下有效，目前仅支持RR策略</p>

<h4 id="rheakvrpcservice">RheaKVRpcService</h4>

<p>针对 kv 服务的 rpc client包装，实现了 failover 逻辑</p>

<h4 id="regionkvservice">RegionKVService</h4>

<p>KV server 端的请求处理服务，一个 StoreEngine 中包含很多 RegionKVService, 每个 RegionKVService 对应一个region，只处理自己 region 范围内的请求</p>

<h4 id="metricsrawkvstore">MetricsRawKVStore</h4>

<p>拦截请求做指标度量</p>

<h4 id="raftrawkvstore">RaftRawKVStore</h4>

<p>RheaKV 的 raft 入口，从这里开始 raft 流程</p>

<h4 id="kvstorestatemachine">KVStoreStateMachine</h4>

<p>实现了 raft 状态机</p>

<h4 id="rocksrawkvstore">RocksRawKVStore</h4>

<p>原始的 rocksdb api 封装， 目前 rheaKV 也支持可插拔的 memoryDB 存储实现</p>

<h3 id="pd-模块内部处理流程">PD 模块内部处理流程</h3>

<p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*38DLRJ_YScUAAAAAAAAAAABjARQnAQ" alt="PD 模块内部处理流程" /></p>

<h4 id="概述">概述</h4>

<p>PD 模块主要参考 <a href="https://github.com/tikv/tikv">tikv</a> 的设计理念，尤其是下面会提到的两类 Heartbeat 内容，不过由于目前这部分的应用场景缺失，并没有完全实现自管理自驱动，目前只实现了自动平衡所有节点的分区 leader 以及自动分裂</p>

<h4 id="placementdriverclient-metadataclient">PlacementDriverClient -&gt; MetadataClient</h4>

<p>MetadataClient 负责从 PD 获取集群元信息以及注册元信息</p>

<h4 id="storeengine-heartbeatsender">StoreEngine -&gt; HeartbeatSender</h4>

<ul>
<li>HeartbeatSender 负责发送当前存储节点的心跳，心跳中包含一些状态信息，心跳一共分为两类：StoreHeartbeat 和 RegionHeartbeat</li>
<li>PD 不断接受 rheaKV 集群这两类心跳消息，PD 在对 region leader 的心跳回复里面包含了具体调度指令，再以这些信息作为决策依据。除此之外，PD 还应该可以通过管理接口接收额外的运维指令，用来人为执行更准确的决策</li>
<li>两类心跳包含的状态信息详细内容如下：</li>
</ul>

<p><strong>StoreHeartbeat</strong></p>

<pre><code class="language-java">   public class StoreStats implements Serializable {
       private long            storeId;
       // Store总容量(磁盘)
       private long            capacity;
       // Store可用容量
       private long            available;
       // Store承载的region数量
       private int             regionCount;
       // 正在发送的snapshot数量
       private int             sendingSnapCount;
       // 正在接收的snapshot数量
       private int             receivingSnapCount;
       // 有多少region正在apply snapshot
       private int             applyingSnapCount;
       // Store的启动时间 (unix timestamp in milliseconds)
       private long            startTime;
       // Store是否忙碌
       private boolean         isBusy;
       // 被Store实际使用的磁盘大小
       private long            usedSize;
       // 当前一个周期内的写入数据量
       private long            bytesWritten;
       // 当前一个周期内的读取数据量
       private long            bytesRead;
       // 当前一个周期内写入的key的个数
       private long            keysWritten;
       // 当前一个周期内读取的key的个数
       private long            keysRead;
       // 一个周期的具体时间长度
       private TimeInterval    interval;
   }
</code></pre>

<p><strong>RegionHeartbeat</strong></p>

<pre><code class="language-java">        public class RegionStats implements Serializable {
            private long                regionId;
            // Region的leader位置, 负责发送心跳
            private Peer                leader;
            // 掉线的peer列表
            private List&lt;PeerStats&gt;     downPeers;
            // 暂时还不能work的follower
            private List&lt;PeerStats&gt;     pendingPeers;
            // 当前一个周期内的写入数据量
            private long                bytesWritten;
            // 当前一个周期内的读取数据量
            private long                bytesRead;
            // 当前一个周期内写入的key的个数
            private long                keysWritten;
            // 当前一个周期内读取的key的个数
            private long                keysRead;
            // Region占用空间的大小(近似值即可)
            private long                approximateSize;
            // Region包含key的个数(近似值即可)
            private long                approximateKeys;
            // 一个周期的具体时间长度
            private TimeInterval        interval;
        }
</code></pre>

<h4 id="pipeline">Pipeline</h4>

<p>是针对心跳上报 Stats 的计算以及存储处理流水线，处理单元 (Handler) 可插拔，非常方便扩展</p>

<h4 id="metadatastore">MetadataStore</h4>

<p>负责集群元信息存储以及查询，存储方面基于内嵌的 RheaKV</p>

<h3 id="客户端路由">客户端路由</h3>

<h4 id="分片逻辑-regionroutetable"><strong>分片逻辑：RegionRouteTable</strong></h4>

<p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*NySFTZrZ8l4AAAAAAAAAAABjARQnAQ" alt="分片逻辑" /></p>

<p>可以看到，实现上图最适合的数据结构便是跳表或者二叉树（最接近匹配项查询）</p>

<p>选择 region 的 startKey 还是 endKey 作为 RegionRouteTable 的 key 也是有讲究的，比如为什么没有使用endKey? 这主要取决于 region split 的方式：</p>

<ul>
<li>假设 id 为 2 的 region2 [startKey2, endKey2) 分裂</li>
<li>它分裂后的两个 region 分别为 id 继续为 2 的 region2 [startKey2, splitKey) 和 id 为 3 的 region3 [splitKey, endKey2)</li>
<li>可以再看上图会发现，此时只需要再往 regionRouteTable 添加一个元素 <code>&lt;region3, splitKey&gt;</code> 即可，原来region2 对应的数据是不需要修改的

<ul>
<li><strong>Write-Operation</strong>

<ul>
<li>单 key 写请求路由逻辑很简单，根据 key 查询对应的 region，再对该 region 发起请求即可。</li>
<li>如果是一个批量操作写请求，比如 <code>put(List)</code>，那么会对所有 keys 进行 split，分组后再并行分别请求所属的regionEngine，要注意的是此时无法提供事务保证。</li>
</ul></li>
<li><strong>Read-Operation</strong>

<ul>
<li>单 key 读请求路由逻辑也很简单，根据 key 查询对应的 region，再对该 region 发起请求即可。</li>
<li>如果是一个批量读请求，比如 scan(startKey, endKey)，那么会对所有 keys 进行 split，分组后并行再分别请求所属的 regionEngine。</li>
</ul></li>
</ul></li>
</ul>

<h4 id="failover">Failover</h4>

<p><strong>RheaKV 对用户端提供的是异步 api, 这就要求 failover 的处理流程必须也得是异步, 这对设计增加了一些难度，实现会绕一点</strong></p>

<p><strong>以下问题是RheaKV必须要解决的:</strong></p>

<ol>
<li>异步失败 retry</li>
<li>调用时遇到 membership change，需要刷新 membership 重试</li>
<li>一次操作多个 key (比如range scan) 时遭遇 region 自动 split，需要在 retry 时也能自动分裂(放大)请求，并异步合并多个响应结果</li>
<li>前一次操作可能是本地调用，retry 时却可能需要发起远程调用，也可能是反过来的情况，两种情况都需要兼容</li>
</ol>

<p><strong>RheaKV 可以划分为两种类型的请求，两种类型需要不同的 failover 逻辑：</strong></p>

<ul>
<li><strong>Single-Key-Operation (只操作一个 key)</strong>
Retry 依赖一个叫做 FailoverClosure 的 callback类，大体逻辑如下:</li>
</ul>

<pre><code class="language-java">    public void run(final Status status) {
        if (status.isOk()) {
            // 成功
            success((T) getData());
        } else if (this.retriesLeft &gt; 0 &amp;&amp;
                (isInvalidPeer(getError()) || (this.retryOnInvalidEpoch &amp;&amp; isInvalidEpoch(getError())))) {
            // 重试
            this.retryRunner.run(getError());
        } else {
            // 失败
            failure(getError());
        }
    }
</code></pre>

<p>其中有以下两大类错误(表①、表②)会触发 retryRunner 运行，运行之前会先刷新 region 信息以及 group peers(路由表)</p>

<hr />

<p>表①</p>

<table>
<thead>
<tr>
<th align="left">NOT_LEADER</th>
<th align="left">当前节点不是Leader</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">NO_REGION_FOUND</td>
<td align="left">当前机器未找到指定的RegionEngine</td>
</tr>

<tr>
<td align="left">LEADER_NOT_AVAILABLE</td>
<td align="left">当前的Region Group可能还未选举出Leader</td>
</tr>
</tbody>
</table>

<hr />

<p>表②</p>

<table>
<thead>
<tr>
<th align="left">INVALID_REGION_MEMBERSHIP</th>
<th align="left">当前Region Group已经发生了成员变化, 比如新增或删除了节点</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">INVALID_REGION_VERSION</td>
<td align="left">当前Region分裂(split)了</td>
</tr>

<tr>
<td align="left">INVALID_REGION_EPOCH</td>
<td align="left">表示可能为INVALID_REGION_MEMBERSHIP或INVALID_REGION_VERSION任意一个</td>
</tr>
</tbody>
</table>

<hr />

<p><strong>Multi-Keys-Operation (操作多个key或一个key区间)</strong></p>

<ol>
<li>对于多个 key 的请求，还要先对 keys 做 split，每个 region 包含一部分数量的 keys，对于每个 region 有单独 failover 处理，此时 FailoverClosure 类只能处理表①中的作为类型，处理逻辑同 <strong>Single-Key-Operation</strong></li>
<li>对于表②中三个 region epoch 发生变更的错误，FailoverClosure 无法处理，因为在epoch发生变化时，很有可能是发生了 region split，对于先前定位的 region，分裂成了 2 个，此时不光需要重新从 PD 刷新region 信息，failover 还要处理请求的放大(多个 region 就会产生多个请求)，所以新增了几类 <strong>FailoverFuture</strong> 来处理这种请求放大的逻辑</li>
<li>其中 <strong>scan(startKey, endKey)</strong> 的 FailoverFuture 主要逻辑如下图, 可以看到整个流程是完全异步的</li>
</ol>

<pre><code class="language-java">        @Override
        public boolean completeExceptionally(final Throwable ex) {
            if (this.retriesLeft &gt; 0 &amp;&amp; ApiExceptionHelper.isInvalidEpoch(ex)) {
                LOG.warn(&quot;[InvalidEpoch-Failover] cause: {}, [{}] retries left.&quot;, StackTraceUtil.stackTrace(ex),
                        this.retriesLeft);
                // 遇到 invalid epoch，重试，可能会请求分裂，所以返回一个 FutureGroup
                final FutureGroup&lt;List&lt;T&gt;&gt; futureGroup = this.retryCallable.run(ex);
                CompletableFuture.allOf(futureGroup.toArray()).whenComplete((ignored, throwable) -&gt; {
                    if (throwable == null) {
                        final List&lt;T&gt; all = Lists.newArrayList();
                        for (final CompletableFuture&lt;List&lt;T&gt;&gt; partOf : futureGroup.futures()) {
                            all.addAll(partOf.join());
                        }
                        // 整个 group 均已完成
                        super.complete(all);
                    } else {
                        // 异常完成
                        super.completeExceptionally(throwable);
                    }
                });
                return false;
            }
            if (this.retriesLeft &lt;= 0) {
                LOG.error(&quot;[InvalidEpoch-Failover] cause: {}, {} retries left.&quot;, StackTraceUtil.stackTrace(ex),
                        this.retriesLeft);
            }
            // 剩余重试为 0，或者当前的异常类型不需要重试
            return super.completeExceptionally(ex);
        }
</code></pre>

<h4 id="举例-一次-scan-的流程">举例: 一次 scan 的流程</h4>

<ul>
<li><strong>确定 key 区间 [startKey, endKey) 覆盖的 region list</strong>

<ul>
<li>RegionRouteTable#findRegionsByKeyRange(startKey, endKey)</li>
<li>RegionRouteTable 是一个红黑树结构存储的 region 路由表，startKey 为作为红黑树的key，只要查找 [startKey, endKey) 的子视图再加上一个 floorEntry(startKey) 即可</li>
<li>如下图例子，计算得出 [startKey, endKey) 横跨 region1, region2, region3 一共 3 个分区(region1 为 floor entry, region2 和 region3 为子视图部分)</li>
</ul></li>
</ul>

<p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*5gBCRJZjEqAAAAAAAAAAAABjARQnAQ" alt="region list" /></p>

<ul>
<li><strong>请求分裂: scan -&gt; multi-region scan</strong>

<ul>
<li>region1 -&gt; regionScan(startKey, regionEndKey1)</li>
<li>region2 -&gt; regionScan(regionStartKey2, regionEndKey2)</li>
<li>region3 -&gt; regionScan(regionStartKey3, endKey)</li>
</ul></li>
</ul>

<p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*BLVgSaFlAgoAAAAAAAAAAABjARQnAQ" alt="请求分裂" /></p>

<ul>
<li><strong>遭遇 region split (分裂的标志是 region epoch 发生变化)</strong>

<ul>
<li>刷新 RegionRouteTable，需要从 PD 获取最新的路由表，比如当前示例中 region2 分裂变成了 region2 + region5

<ul>
<li>region2 -&gt; regnonScan(regionStartKey2, regionEndKey2)  请求分裂并重试

<ul>
<li>region2 -&gt; regionScan(regionStartKey2, newRegionEndKey2)</li>
<li>region5 -&gt; regionScan(regionStartKey5, regionEndKey5)</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*Cr5gT4FFs3QAAAAAAAAAAABjARQnAQ" alt="region split" /></p>

<ul>
<li><strong>遭遇 Invalid Peer (NOT_LEADER 等错误)</strong>

<ul>
<li>这个就很简单了, 重新获取当前 key 区间所属的 raft-group 的最新 leader，再次发起调用即可</li>
</ul></li>
</ul>

</article>

<script>
  const article = document.querySelector('article.typo')
  
  const imgElements = article.querySelectorAll('img');
  
  imgElements.forEach(img => {
    const src = img.getAttribute('src');
    
    if (src.toLowerCase().endsWith('.image')) {
      img.setAttribute('src', src.replace('.image', ''));
    }
    img.setAttribute('referrerpolicy', 'no-referrer');
  });
</script>


	</main>
</div>



	


<footer class="ss-footer">
	<div class="container">
		<div class="links">
			
				<div class="cate">
					<h2 class="cate-title">资源</h2>
					
						<a class="link" href="https://github.com/sofastack">Github</a>
					
						<a class="link" href="https://gitee.com/sofastack/">Gitee</a>
					
						<a class="link" href="https://github.com/sofastack-guides">示例</a>
					
				</div>
			
				<div class="cate">
					<h2 class="cate-title">社交媒体</h2>
					
						<a class="link" href="https://zhuanlan.zhihu.com/sofastack">知乎专栏</a>
					
						<a class="link" href="https://weibo.com/sofastack">新浪微博</a>
					
						<a class="link" href="https://twitter.com/sofastack_io">Twitter</a>
					
				</div>
			
				<div class="cate">
					<h2 class="cate-title">参与进来</h2>
					
						<a class="link" href="https://github.com/sofastack/sofastack.tech/issues/new">反馈</a>
					
						<a class="link" href="https://github.com/sofastack/community">社区</a>
					
						<a class="link" href="https://github.com/sofastack/sofastack.tech/wiki">Wiki</a>
					
						<a class="link" href="mailto:sofa@alipay.cloud.com">Email</a>
					
						<a class="link" href="/hr/">加入我们</a>
					
				</div>
			
				<div class="cate">
					<h2 class="cate-title">蚂蚁集团开源项目</h2>
					
						<a class="link" href="https://ant.design/">Ant Design</a>
					
						<a class="link" href="https://eggjs.org/">Egg </a>
					
						<a class="link" href="https://sqlflow.org">SQLFlow</a>
					
						<a class="link" href="https://tech.antfin.com/open-source">更多</a>
					
				</div>
			
		</div>
		<div class="qrcode">
			
				<div>
					<img class="qrcode-img" src="/sofastack.tech/img/qrcode/qrcode_video.png" />
					<p class="qrcode-desc">微信视频号</p>
				</div>
			
				<div>
					<img class="qrcode-img" src="/sofastack.tech/img/qrcode/qrcode_1.png" />
					<p class="qrcode-desc">微信公众号</p>
				</div>
			
				<div>
					<img class="qrcode-img" src="/sofastack.tech/img/qrcode/dingtalk_7.jpg" />
					<p class="qrcode-desc">钉钉群</p>
				</div>
			
		</div>
	</div>
	<div class="copyright">
		<p>
			© 2018 - 2022  The SOFAStack Authors
			<a href="http://beian.miit.gov.cn/">浙 ICP 备 16045294 号-3</a>
		</p>
	</div>
</footer>

</body>

</html>