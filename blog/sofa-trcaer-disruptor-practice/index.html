<!DOCTYPE html>
<html>

<head>
	<title>
	蚂蚁金服分布式链路跟踪组件 SOFATracer 中 Disruptor 实践（含源码） · SOFAStack
</title>
	<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="SOFAStack is a Scalable Open Financial Architecture for building cloud native applications" />

<meta name="generator" content="Hugo 0.55.5" /><link rel="shortcut icon" href=https://img.alicdn.com/imgextra/i3/O1CN019CRHyf1qyMghfS3id_!!6000000005564-2-tps-211-128.png type="image/png">

<link href="https://unpkg.com/purecss@1.0.0/build/base-min.css" rel="stylesheet">



<link href="/sofastack.tech/css/main.css" rel="stylesheet">
<link href="/sofastack.tech/css/zoom-image.css" rel="stylesheet">

<script src="/sofastack.tech/js/iconfont.js"></script>
<script src="/sofastack.tech/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<script>window.SITE_LANGUAGE = "zh"</script>
<script src="/sofastack.tech/js/app.js"></script>





<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-142131411-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</head>

<body>
	<header class="ss-header">
	<nav class="navbar" role="navigation" aria-label="main navigation">
		<div class="navbar-brand">
			<a class="logo-link" href="/sofastack.tech/">
				<img class="logo" src="/sofastack.tech/img/logo-2024.png">
			</a>
			<div class="-show-mobile">
				<a id="mobile-menu-icon">
					<svg class="icon" aria-hidden="true">
						<use xlink:href="#icon-menu"></use>
					</svg>
				</a>
				<nav id="mobile-menu">
						<div id="js-menu-search-mobile" class="navbar-search-mobile">
							<input class="input" placeholder="请输入要搜索的关键词">
							<svg class="icon" aria-hidden="true">
								<use xlink:href="#icon-search"></use>
							</svg>
						</div>
					
          
            <a
              class=""
              href="/sofastack.tech/projects/">
              <span>
                项目
              </span>
              <svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"></use></svg>
            </a>
					
            <a
              class=""
              href="/sofastack.tech/guides/">
              <span>
                指南
              </span>
              <svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"></use></svg>
            </a>
					
            <a
              class=""
              href="/sofastack.tech/blog/">
              <span>
                博客
              </span>
              <svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"></use></svg>
            </a>
					
            <a
              class=""
              href="/sofastack.tech/activities/">
              <span>
                活动
              </span>
              <svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"></use></svg>
            </a>
					
            <a
              class=""
              href="/sofastack.tech/community/">
              <span>
                社区
              </span>
              <svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"></use></svg>
            </a>
					
            <a
              class=""
              href="/sofastack.tech/awesome/">
              <span>
                Awesome SOFA
              </span>
              <svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"></use></svg>
            </a>
					
					
				</nav>
			</div>
		</div>

		<div class="navbar-menu -hidden-mobile">
			<div class="navbar-start">
				
				
					<a class="navbar-item "
						href="/sofastack.tech/projects/">项目</a>
				
					<a class="navbar-item "
						href="/sofastack.tech/guides/">指南</a>
				
					<a class="navbar-item "
						href="/sofastack.tech/blog/">博客</a>
				
					<a class="navbar-item "
						href="/sofastack.tech/activities/">活动</a>
				
					<a class="navbar-item "
						href="/sofastack.tech/community/">社区</a>
				
					<a class="navbar-item "
						href="/sofastack.tech/awesome/">Awesome SOFA</a>
				
			</div>
			<div class="navbar-end">
				<div class="navbar-item">
					<div id="js-menu-search" class="navbar-search">
						<input class="input" placeholder="请输入要搜索的关键词">
						<svg class="icon" aria-hidden="true">
							<use xlink:href="#icon-search"></use>
						</svg>
					</div>
				</div>
				<div class="navbar-item">
					
				</div>
			</div>
		</div>
	</nav>
</header>


	

	

	

	

	

	



	

<div class="ss-layout-container">
	<main class="ss-layout-main -card">
		<div class="ss-meta">
	<h1 class="title">
		蚂蚁金服分布式链路跟踪组件 SOFATracer 中 Disruptor 实践（含源码）
	</h1>
	<div class="meta">
		
			2020-03-17 ·
			
				<a href="http://www.glmapper.com/">卫恒</a> ·
			
			<span class="tags">
				
					<a class="tag" href="/sofastack.tech/tags/sofatracer/" rel="tag">#SOFATracer</a>
				
			</span>
		
	</div>
</div>
		<article class="typo">
  <blockquote>
<p><strong>SOFA</strong>Stack（<strong>S</strong>calable <strong>O</strong>pen <strong>F</strong>inancial <strong>A</strong>rchitecture Stack）是蚂蚁金服自主研发的金融级云原生架构，包含了构建金融级云原生架构所需的各个组件，是在金融场景里锤炼出来的最佳实践。</p>

<p>SOFATracer 是一个用于分布式系统调用跟踪的组件，通过统一的 TraceId 将调用链路中的各种网络调用情况以日志的方式记录下来，以达到透视化网络调用的目的，这些链路数据可用于故障的快速发现，服务治理等。</p>

<p>SOFATracer：<a href="https://github.com/sofastack/sofa-tracer">https://github.com/sofastack/sofa-tracer</a></p>
</blockquote>

<h2 id="disruptor-简介">Disruptor 简介</h2>

<p>Disruptor 旨在在异步事件处理体系结构中提供低延迟，高吞吐量的工作队列。它确保任何数据仅由一个线程拥有以进行写访问，因此与其他结构相比，减少了写争用。目前，包括 Apache Storm、Camel、Log4j 2 在内的很多知名项目都应用了 Disruptor 以获取高性能。</p>

<p>SOFATracer 也是基于 <a href="https://github.com/LMAX-Exchange/disruptor">Disruptor</a> 高性能无锁循环队列来提供异步打印日志到本地磁盘能力的，SOFATracer 提供两种类似的日志打印类型即摘要日志和统计日志，摘要日志：每一次调用均会落地磁盘的日志；统计日志：每隔一定时间间隔进行统计输出的日志；无论是哪种日志的输出，对于 SOFATracer 来说都需要保证较高的性能，以降低对于业务整体流程耗时的影响。</p>

<p>关于 Disruptor 的 一些原理分析可以参考：<a href="https://ifeve.com/disruptor/">Disruptor</a> 。</p>

<blockquote>
<p>A High Performance Inter-Thread Messaging Library 高性能的线程间消息传递库</p>
</blockquote>

<h2 id="案例">案例</h2>

<p>先通过 Disruptor 的一个小例子来有个直观的认识；先看下它的构造函数：</p>

<pre><code class="language-java">public Disruptor(
        final EventFactory&lt;T&gt; eventFactory,
        final int ringBufferSize,
        final ThreadFactory threadFactory,
        final ProducerType producerType,
        final WaitStrategy waitStrategy)
{
    this(
        RingBuffer.create(producerType, eventFactory, ringBufferSize, waitStrategy),
        new BasicExecutor(threadFactory));
}
</code></pre>

<ul>
<li>eventFactory : 在环形缓冲区中创建事件的 factory；</li>
<li>ringBufferSize:环形缓冲区的大小，必须是2的幂；</li>
<li>threadFactory：用于为处理器创建线程；</li>
<li>producerType：生成器类型以支持使用正确的sequencer和publisher创建RingBuffer；枚举类型，SINGLE、MULTI两个项。对应于 SingleProducerSequencer和MultiProducerSequencer两种Sequencer；</li>
<li>waitStrategy : 等待策略；</li>
</ul>

<p>如果我们想构造一个 disruptor，那么我们就需要上面的这些组件。从 eventFactory 来看，还需要一个具体的 Event 来作为消息事件的载体。【下面按照官方给的案例进行简单的修改作为示例】</p>

<h3 id="消息事件-longevent-能够被消费的数据载体">消息事件 LongEvent ，能够被消费的数据载体</h3>

<pre><code class="language-java">public class LongEvent {
    private long value;
    public void set(long value) {
        this.value = value;
    }
    public long getValue() {
        return value;
    }
}
</code></pre>

<h3 id="创建消息事件的-factory">创建消息事件的 factory</h3>

<pre><code class="language-java">public class LongEventFactory implements EventFactory&lt;LongEvent&gt; {
    @Override
    public LongEvent newInstance() {
        return new LongEvent();
    }
}
</code></pre>

<h3 id="consumerthreadfactory">ConsumerThreadFactory</h3>

<pre><code class="language-java">public class ConsumerThreadFactory implements ThreadFactory {
    private final AtomicInteger index = new AtomicInteger(1);
    @Override
    public Thread newThread(Runnable r) {
        return new Thread(r, &quot;disruptor-thread-&quot; + index.getAndIncrement());
    }
}
</code></pre>

<p>OK ，上面的这些可以满足创建一个 disruptor 了：</p>

<pre><code class="language-java">private int ringBufferCapacity = 8;
//消息事件生产Factory
LongEventFactory longEventFactory = new LongEventFactory();
//执行事件处理器线程Factory
ConsumerThreadFactory consumerThreadFactory = new ConsumerThreadFactory();
//用于环形缓冲区的等待策略。
WaitStrategy waitStrategy = new BlockingWaitStrategy();

//构建disruptor
Disruptor&lt;LongEvent&gt; disruptor = new Disruptor&lt;&gt;(
    longEventFactory,
    ringBufferCapacity,
    longEventThreadFactory,
    ProducerType.SINGLE,
    waitStrategy);
</code></pre>

<p>现在是已经有了 disruptor 了，然后通过：start 来启动：</p>

<pre><code class="language-java">//启动 disruptor
 disruptor.start();
</code></pre>

<p>到这里，已经构建了一个disruptor；但是目前怎么使用它来发布消息和消费消息呢？</p>

<h3 id="发布消息">发布消息</h3>

<p>下面在 for 循环中 发布 5 条数据：</p>

<pre><code class="language-java">RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();
for (long l = 0; l &lt; 5; l++)
{
    long sequence = ringBuffer.next();
    LongEvent event = ringBuffer.get(sequence);
    event.set(100+l);
    System.out.println(&quot;publish event :&quot; + l);
    ringBuffer.publish(sequence);
    Thread.sleep(1000);
}
</code></pre>

<p>消息已经发布，下面需要设定当前 disruptor 的消费处理器。前面已经有个 LongEvent 和 EventFactory ; 在 disruptor 中是通过 EventHandler 来进行消息消费的。</p>

<h3 id="编写消费者代码">编写消费者代码</h3>

<pre><code class="language-java">public class LongEventHandler implements EventHandler&lt;LongEvent&gt; {
    @Override
    public void onEvent(LongEvent event, long sequence, boolean endOfBatch) throws Exception {
        System.out.println(&quot;Event: &quot; + event.getValue()+&quot; -&gt; &quot; + Thread.currentThread().getName());
        Thread.sleep(2000);
    }
}
</code></pre>

<p>将 eventHandler 设置到 disruptor 的处理链上：</p>

<pre><code class="language-java">//将处理事件的事件处理程序 -&gt; 消费事件的处理程序
LongEventHandler longEventHandler = new LongEventHandler();
disruptor.handleEventsWith(longEventHandler);
</code></pre>

<h3 id="运行结果-这里">运行结果（这里）</h3>

<pre><code>publish event :0
Event: 0 -&gt; disruptor-thread-1
--------------------------------&gt;
publish event :1
Event: 1 -&gt; disruptor-thread-1
--------------------------------&gt;
publish event :2
Event: 2 -&gt; disruptor-thread-1
--------------------------------&gt;
publish event :3
Event: 3 -&gt; disruptor-thread-1
--------------------------------&gt;
publish event :4
Event: 4 -&gt; disruptor-thread-1
--------------------------------&gt;
</code></pre>

<h2 id="基本概念和原理">基本概念和原理</h2>

<h3 id="disruptor">Disruptor</h3>

<p>整个基于 ringBuffer 实现的生产者消费者模式的容器。主要属性：</p>

<pre><code class="language-java">private final RingBuffer&lt;T&gt; ringBuffer;
private final Executor executor;
private final ConsumerRepository&lt;T&gt; consumerRepository = new ConsumerRepository&lt;&gt;();
private final AtomicBoolean started = new AtomicBoolean(false);
private ExceptionHandler&lt;? super T&gt; exceptionHandler = new ExceptionHandlerWrapper&lt;&gt;();
</code></pre>

<ul>
<li>ringBuffer：内部持有一个 RingBuffer 对象，Disruptor 内部的事件发布都是依赖这个 RingBuffer 对象完成的；</li>
<li>executor：消费事件的线程池；</li>
<li>consumerRepository：提供存储库机制，用于将 EventHandler 与 EventProcessor 关联起来；</li>
<li>started : 用于标志当前 Disruptor 是否已经启动；</li>
<li>exceptionHandler : 异常处理器，用于处理 BatchEventProcessor 事件周期中 uncaught exceptions；</li>
</ul>

<h3 id="ringbuffer">RingBuffer</h3>

<p>环形队列【实现上是一个数组】，可以类比为 BlockingQueue 之类的队列，ringBuffer 的使用，使得内存被循环使用，减少了某些场景的内存分配回收扩容等耗时操作。</p>

<pre><code class="language-java">public final class RingBuffer&lt;E&gt; extends RingBufferFields&lt;E&gt; 
implements Cursored, EventSequencer&lt;E&gt;, EventSink&lt;E&gt;
</code></pre>

<ul>
<li>E：在事件的交换或并行协调期间存储用于共享的数据的实现 -&gt; 消息事件；</li>
</ul>

<h3 id="sequencer">Sequencer</h3>

<p>RingBuffer 中生产者的顶级父接口，其直接实现有 SingleProducerSequencer 和 MultiProducerSequencer；对应 SINGLE、MULTI 两个枚举值。</p>

<p><img src="https://cdn.nlark.com/yuque/0/2020/png/226702/1584325942316-c50296fc-41b9-4b59-b8e0-34ffaa3da763.png#align=left&amp;display=inline&amp;height=768&amp;originHeight=768&amp;originWidth=1046&amp;size=0&amp;status=done&amp;style=none&amp;width=1046" alt="Sequencer" /></p>

<h3 id="eventhandler">EventHandler</h3>

<p>事件处置器，改接口用于对外扩展来实现具体的消费逻辑。如上面 Demo 中的 LongEventHandler ;</p>

<pre><code class="language-java">//回调接口，用于处理{@link RingBuffer}中可用的事件
public interface EventHandler&lt;T&gt; {
    void onEvent(T event, long sequence, boolean endOfBatch) throws Exception;
}
</code></pre>

<ul>
<li>event : RingBuffer 已经发布的事件；</li>
<li>sequence : 正在处理的事件的序列号；</li>
<li>endOfBatch : 用来标识否是来自 RingBuffer 的批次中的最后一个事件；</li>
</ul>

<h3 id="sequencebarrier">SequenceBarrier</h3>

<p>消费者路障，规定了消费者如何向下走。事实上，该路障算是变向的锁。</p>

<pre><code class="language-java">final class ProcessingSequenceBarrier implements SequenceBarrier {
    //当等待（探测）的需要不可用时，等待的策略
    private final WaitStrategy waitStrategy;
    //依赖的其它Consumer的序号，这个用于依赖的消费的情况，
    //比如A、B两个消费者，只有A消费完，B才能消费。
    private final Sequence     dependentSequence;
    private volatile boolean   alerted = false;
    //Ringbuffer的写入指针
    private final Sequence     cursorSequence;
    //RingBuffer对应的Sequencer
    private final Sequencer    sequencer;
    //exclude method
}
</code></pre>

<p>waitStrategy 决定了消费者采用何种等待策略。</p>

<h3 id="waitstrategy">WaitStrategy</h3>

<blockquote>
<p>Strategy employed for making {[@link ]() EventProcessor}s wait on a cursor {[@link ]() Sequence}.</p>
</blockquote>

<p>EventProcessor 的等待策略；具体实现在 disruptor 中有 8 种：</p>

<p><img src="https://cdn.nlark.com/yuque/0/2020/png/226702/1584325942359-de8e1e42-6e96-468d-a67b-5bb2dd619649.png" alt="在 disruptor 的8中具体实现" /></p>

<p>这些等待策略不同的核心体现是在如何实现 waitFor 这个方法上。</p>

<h3 id="eventprocessor">EventProcessor</h3>

<p>事件处理器，实际上可以理解为消费者模型的框架，实现了线程 Runnable 的 run 方法，将循环判断等操作封在了里面。该接口有三个实现类:</p>

<p><strong>1、BatchEventProcessor</strong></p>

<pre><code class="language-java">public final class BatchEventProcessor&lt;T&gt; implements EventProcessor {
    private final AtomicBoolean           running          = new AtomicBoolean(false);
    private ExceptionHandler&lt;? super T&gt;   exceptionHandler = new FatalExceptionHandler();
    private final DataProvider&lt;T&gt;         dataProvider;
    private final SequenceBarrier         sequenceBarrier;
    private final EventHandler&lt;? super T&gt; eventHandler;
    private final Sequence                sequence         = new Sequence(                                      Sequencer.INITIAL_CURSOR_VALUE);
    private final TimeoutHandler          timeoutHandler;
    //exclude method
}
</code></pre>

<ul>
<li>ExceptionHandler：异常处理器；</li>
<li>DataProvider：数据来源，对应 RingBuffer；</li>
<li>EventHandler：处理 Event 的回调对象；</li>
<li>SequenceBarrier：对应的序号屏障；</li>
<li>TimeoutHandler：超时处理器，默认情况为空，如果要设置，只需要要将关联的 EventHandler 实现 TimeOutHandler 即可；</li>
</ul>

<p>如果我们选择使用 EventHandler 的时候，默认使用的就是 BatchEventProcessor，它与 EventHandler 是一一对应，并且是单线程执行。</p>

<p>如果某个 RingBuffer 有多个 BatchEventProcessor，那么就会每个 BatchEventProcessor 对应一个线程。</p>

<p><strong>2、WorkProcessor</strong></p>

<pre><code class="language-java">public final class WorkProcessor&lt;T&gt; implements EventProcessor {
    private final AtomicBoolean running = new AtomicBoolean(false);
    private final Sequence sequence = new Sequence(Sequencer.INITIAL_CURSOR_VALUE);
    private final RingBuffer&lt;T&gt; ringBuffer;
    private final SequenceBarrier  sequenceBarrier;
    private final WorkHandler&lt;? super T&gt; workHandler;
    private final ExceptionHandler&lt;? super T&gt; exceptionHandler;
    private final Sequence workSequence;

    private final EventReleaser eventReleaser = new EventReleaser() {
            @Override
            public void release() {
                sequence.set(Long.MAX_VALUE);
            }
    };
    private final TimeoutHandler timeoutHandler;
}
</code></pre>

<p>基本和 BatchEventProcessor 类似，不同在于用于处理 Event 的回调对象是 WorkHandler。</p>

<h3 id="原理图">原理图</h3>

<p><img src="https://cdn.nlark.com/yuque/0/2020/png/226702/1584325942377-8e0666a6-bd2c-40ee-b1b7-df4f9d5ae46f.png" alt="原理图" /></p>

<p>无消费者情况下，生产者保持生产，但是 remainingCapacity 保持不变。</p>

<p>在写 Demo 的过程中，本来想通过不设定消费者来观察 RingBuffer 可用容量变化的。但是验证过程中，一直得不到预期的结果，(注：没有设置消费者，只有生产者)，先看结果：</p>

<pre><code>publish event :0
bufferSie:8
remainingCapacity:8
cursor:0
--------------------------------&gt;
publish event :1
bufferSie:8
remainingCapacity:8
cursor:1
--------------------------------&gt;
publish event :2
bufferSie:8
remainingCapacity:8
cursor:2
--------------------------------&gt;
publish event :3
bufferSie:8
remainingCapacity:8
cursor:3
--------------------------------&gt;
publish event :4
bufferSie:8
remainingCapacity:8
cursor:4
--------------------------------&gt;
publish event :5
bufferSie:8
remainingCapacity:8
cursor:5
--------------------------------&gt;
publish event :6
bufferSie:8
remainingCapacity:8
cursor:6
--------------------------------&gt;
publish event :7
bufferSie:8
remainingCapacity:8
cursor:7
--------------------------------&gt;
publish event :8
bufferSie:8
remainingCapacity:8
cursor:8
--------------------------------&gt;
publish event :9
bufferSie:8
remainingCapacity:8
cursor:9
--------------------------------&gt;
</code></pre>

<p>从结果来看，remainingCapacity 的值应该随着 发布的数量 递减的；但是实际上它并没有发生任何变化。</p>

<p>来看下 ringBuffer.remainingCapacity() 这个方法：</p>

<pre><code class="language-java">/**
 * Get the remaining capacity for this ringBuffer.
 *
 * @return The number of slots remaining.
 */
public long remainingCapacity()
{
    return sequencer.remainingCapacity();
}
</code></pre>

<p>这里面又使用 sequencer.remainingCapacity() 这个方法来计算的。上面的例子中使用的是 ProducerType.SINGLE，那来看 SingleProducerSequencer 这个里面 remainingCapacity 的实现。</p>

<pre><code class="language-java">@Override
public long remainingCapacity()
{
    //上次申请完毕的序列值
    long nextValue = this.nextValue;
    //计算当前已经消费到的序列值
    long consumed = Util.getMinimumSequence(gatingSequences, nextValue);
    //当前生产到的序列值
    long produced = nextValue;
    return getBufferSize() - (produced - consumed);
}
</code></pre>

<p>来解释下这段代码的含义：</p>

<p>假设当前 ringBuffer 的 bufferSize 是 8 ；上次申请到的序列号是 5，其实也就是说已经生产过占用的序列号是5；假设当前已经消费到的序列号是 3，那么剩余的容量为： 8-（5-2） = 5。</p>

<p><img src="https://cdn.nlark.com/yuque/0/2020/png/226702/1584325942392-6516acd0-ccfe-4a87-8fa6-bfd786147479.png" alt="代码解读" /></p>

<p>因为这里我们可以确定 bufferSize 和 produced 的值了，那么 remainingCapacity 的结果就取决于 getMinimumSequence 的计算结果了。</p>

<pre><code class="language-java">public static long getMinimumSequence(final Sequence[] sequences, long minimum)
{
    for (int i = 0, n = sequences.length; i &lt; n; i++)
    {
        long value = sequences[i].get();
        minimum = Math.min(minimum, value);
    }
    return minimum;
}
</code></pre>

<p>这个方法是从 Sequence 数组中获取最小序列 。如果 sequences 为空，则返回 minimum。回到上一步，看下 sequences 这个数组是从哪里过来的，它的值在哪里设置的。</p>

<pre><code class="language-java">long consumed = Util.getMinimumSequence(gatingSequences, nextValue);
</code></pre>

<p>gatingSequences是 SingleProducerSequencer 父类  AbstractSequencer 中的成员变量：</p>

<pre><code class="language-java">protected volatile Sequence[] gatingSequences = new Sequence[0];
</code></pre>

<p>gatingSequences 是在下面这个方法里面来管理的。</p>

<pre><code class="language-java">/**
 * @see Sequencer#addGatingSequences(Sequence...)
 */
@Override
public final void addGatingSequences(Sequence... gatingSequences)
{
    SequenceGroups.addSequences(this, SEQUENCE_UPDATER, this, gatingSequences);
}
</code></pre>

<p>这个方法的调用栈向前追溯有这几个地方调用了：</p>

<p><img src="https://cdn.nlark.com/yuque/0/2020/png/226702/1584325942367-a24899bc-63ca-4272-9afa-de1d379e93ab.png" alt="调用栈" /></p>

<p>WorkerPool 来管理多个消费者；hangdlerEventsWith 这个方法也是用来设置消费者的。但是在上面的测试案例中我们是想通过不设定消费者只设定生成者来观察环形队列的占用情况，所以 gatingSequences 会一直是空的，因此在计算时会把 produced 的值作为 minimum 返回。这样每次计算就相当于：</p>

<pre><code class="language-java">return getBufferSize() - (produced - produced) === getBufferSize();
</code></pre>

<p>也就验证了为何在不设定消费者的情况下，remainingCapacity 的值会一直保持不变。</p>

<h2 id="sofatracer-中-disruptor-实践">SOFATracer 中 Disruptor 实践</h2>

<p>SOFATracer 中，AsyncCommonDigestAppenderManager 对 Disruptor 进行了封装，用于处理外部组件的Tracer摘要日志。该部分借助 AsyncCommonDigestAppenderManager 的源码来分析下 SOFATracer 如何使用Disruptor 的。</p>

<p>SOFATracer 中使用了两种不同的事件模型，一种是 SOFATracer 内部使用的 StringEvent , 一种是外部扩展使用的 SofaTacerSpanEvent。这里以 SofaTacerSpanEvent 这种事件模型来分析。StringEvent 消息事件模型对应的是 AsyncCommonAppenderManager 类封装的disruptor。</p>

<h3 id="sofatracerspanevent-longevent">SofaTracerSpanEvent ( -&gt; LongEvent)</h3>

<p>定义消息事件模型，SofaTacerSpanEvent 和前面 Demo 中的 LongEvent 基本结构是一样的，主要是内部持有的消息数据不同，LongEvent 中是一个 long 类型的数据，SofaTacerSpanEvent 中持有的是 SofaTracerSpan 。</p>

<pre><code class="language-java">public class SofaTracerSpanEvent {
    private volatile SofaTracerSpan sofaTracerSpan;
    public SofaTracerSpan getSofaTracerSpan() {
        return sofaTracerSpan;
    }
    public void setSofaTracerSpan(SofaTracerSpan sofaTracerSpan) {
        this.sofaTracerSpan = sofaTracerSpan;
    }
}
</code></pre>

<h3 id="consumer-longeventhandler">Consumer ( -&gt; LongEventHandler)</h3>

<p>Consumer 是 AsyncCommonDigestAppenderManager 的内部类；实现了 EventHandler 接口，这个 consumer 就是作为消费者存在的。</p>

<p>在 AsyncCommonAppenderManager 中也有一个，这个地方个人觉得可以抽出去，这样可以使得AsyncCommonDigestAppenderManager/AsyncCommonAppenderManager 的代码看起来更干净。</p>

<pre><code class="language-java">private class Consumer implements EventHandler&lt;SofaTracerSpanEvent&gt; {
       //日志类型集合，非该集合内的日志类型将不会被处理
        protected Set&lt;String&gt; logTypes = Collections.synchronizedSet(new HashSet&lt;String&gt;());
        @Override
        public void onEvent(SofaTracerSpanEvent event, long sequence, boolean endOfBatch)
                                throws Exception {
            // 拿到具体的消息数据 sofaTracerSpan
            SofaTracerSpan sofaTracerSpan = event.getSofaTracerSpan();
            // 如果没有数据，则不做任何处理
            if (sofaTracerSpan != null) {
                try {
                    String logType = sofaTracerSpan.getLogType();
                    // 验证当前日志类型是否可以被当前consumer消费
                    if (logTypes.contains(logType)) {
                        // 获取编码类型
                        SpanEncoder encoder = contextEncoders.get(logType);
                        //获取 appender
                        TraceAppender appender = appenders.get(logType);
                        // 对数据进行编码处理
                        String encodedStr = encoder.encode(sofaTracerSpan);
                        if (appender instanceof LoadTestAwareAppender) {
                            ((LoadTestAwareAppender) appender).append(encodedStr,
                                TracerUtils.isLoadTest(sofaTracerSpan));
                        } else {
                            appender.append(encodedStr);
                        }
                        // 刷新缓冲区，日志输出
                        appender.flush();
                    }
                } catch (Exception e) {
                   // 异常省略
                }
            }
        }

        public void addLogType(String logType) {
            logTypes.add(logType);
        }
    }
</code></pre>

<h3 id="sofatracerspaneventfactory-longeventfactory">SofaTracerSpanEventFactory （-&gt; LongEventFactory）</h3>

<p>用于产生消息事件的 Factory。</p>

<pre><code class="language-java">public class SofaTracerSpanEventFactory implements EventFactory&lt;SofaTracerSpanEvent&gt; {
    @Override
    public SofaTracerSpanEvent newInstance() {
        return new SofaTracerSpanEvent();
    }
}
</code></pre>

<h3 id="consumerthreadfactory-longeventthreadfactory">ConsumerThreadFactory (-&gt; LongEventThreadFactory )</h3>

<p>用来产生消费线程的 Factory。</p>

<pre><code class="language-java">public class ConsumerThreadFactory implements ThreadFactory {
    private String workName;
    public String getWorkName() {
        return workName;
    }
    public void setWorkName(String workName) {
        this.workName = workName;
    }
    @Override
    public Thread newThread(Runnable runnable) {
        Thread worker = new Thread(runnable, &quot;Tracer-AsyncConsumer-Thread-&quot; + workName);
        worker.setDaemon(true);
        return worker;
    }
}
</code></pre>

<h3 id="构建-disruptor">构建 Disruptor</h3>

<p>Disruptor 的构建是在 AsyncCommonDigestAppenderManager 的构造函数中完成的。</p>

<pre><code class="language-java">public AsyncCommonDigestAppenderManager(int queueSize, int consumerNumber) {
    // 使用这个计算来保证realQueueSize是2的次幂（返回当前 大于等于queueSize的最小的2的次幂数 ）
    int realQueueSize = 1 &lt;&lt; (32 - Integer.numberOfLeadingZeros(queueSize - 1));
    //构建disruptor，使用的是 ProducerType.MULTI
    //等待策略是 BlockingWaitStrategy
    disruptor = new Disruptor&lt;SofaTracerSpanEvent&gt;(new SofaTracerSpanEventFactory(),
        realQueueSize, threadFactory, ProducerType.MULTI, new BlockingWaitStrategy());
    //消费者列表
    this.consumers = new ArrayList&lt;Consumer&gt;(consumerNumber);
    
    for (int i = 0; i &lt; consumerNumber; i++) {
        Consumer consumer = new Consumer();
        consumers.add(consumer);
        //设置异常处理程序
        disruptor.setDefaultExceptionHandler(new ConsumerExceptionHandler());
        //绑定消费者
        disruptor.handleEventsWith(consumer);
    }

    //是否允许丢弃，从配置文件获取
    this.allowDiscard = Boolean.parseBoolean(SofaTracerConfiguration.getProperty(
        SofaTracerConfiguration.TRACER_ASYNC_APPENDER_ALLOW_DISCARD, DEFAULT_ALLOW_DISCARD));
    
    if (allowDiscard) {
        //是否记录丢失日志的数量
        this.isOutDiscardNumber = Boolean.parseBoolean(SofaTracerConfiguration.getProperty(
            SofaTracerConfiguration.TRACER_ASYNC_APPENDER_IS_OUT_DISCARD_NUMBER,
            DEFAULT_IS_OUT_DISCARD_NUMBER));
        //是否记录丢失日志的TraceId和RpcId
        this.isOutDiscardId = Boolean.parseBoolean(SofaTracerConfiguration.getProperty(
            SofaTracerConfiguration.TRACER_ASYNC_APPENDER_IS_OUT_DISCARD_ID,
            DEFAULT_IS_OUT_DISCARD_ID));
        //丢失日志的数量达到该阈值进行一次日志输出
        this.discardOutThreshold = Long.parseLong(SofaTracerConfiguration.getProperty(
            SofaTracerConfiguration.TRACER_ASYNC_APPENDER_DISCARD_OUT_THRESHOLD,
            DEFAULT_DISCARD_OUT_THRESHOLD));
        if (isOutDiscardNumber) {
            this.discardCount = new PaddedAtomicLong(0L);
        }
    }
}
</code></pre>

<h3 id="启动-disruptor">启动 Disruptor</h3>

<p>Disruptor 的启动委托给了 AsyncCommonDigestAppenderManager 的 start 方法来执行。</p>

<pre><code class="language-java">public void start(final String workerName) {
    this.threadFactory.setWorkName(workerName);
    this.ringBuffer = this.disruptor.start();
}
</code></pre>

<p>来看下，SOFATracer 中具体是在哪里调用这个 start 的：</p>

<p><img src="https://cdn.nlark.com/yuque/0/2020/png/226702/1584325942382-ba1fdf89-bc8b-4f9d-8f9e-7fe61f916306.png" alt="调用 start" /></p>

<ul>
<li>CommonTracerManager : 这个里面持有了 AsyncCommonDigestAppenderManager 类的一个单例对象，并且是 static 静态代码块中调用了 start 方法；这个用来输出普通日志；</li>
<li>SofaTracerDigestReporterAsyncManager：这里类里面也是持有了AsyncCommonDigestAppenderManager 类的一个单例对像，并且提供了 getSofaTracerDigestReporterAsyncManager 方法来获取该单例，在这个方法中调用了 start 方法；该对象用来输出摘要日志；</li>
</ul>

<h3 id="发布事件">发布事件</h3>

<p>前面的 Demo 中是通过一个 for 循环来发布事件的，在 SOFATracer 中的事件发布无非就是当有 Tracer 日志需要输出时会触发发布，那么对应的就是日志的 append 操作，将日志 append 到环形缓冲区。</p>

<pre><code class="language-java">public boolean append(SofaTracerSpan sofaTracerSpan) {
    long sequence = 0L;
    //是否允许丢弃
    if (allowDiscard) {
        try {
            //允许丢弃就使用tryNext尝试申请序列，申请不到抛出异常
            sequence = ringBuffer.tryNext();
        } catch (InsufficientCapacityException e) {
            //是否输出丢失日志的TraceId和RpcId
            if (isOutDiscardId) {
                SofaTracerSpanContext sofaTracerSpanContext = sofaTracerSpan
                    .getSofaTracerSpanContext();
                if (sofaTracerSpanContext != null) {
                    SynchronizingSelfLog.warn(&quot;discarded tracer: traceId[&quot;
                                              + sofaTracerSpanContext.getTraceId()
                                              + &quot;];spanId[&quot; + sofaTracerSpanContext.getSpanId()
                                              + &quot;]&quot;);
                }
            }
             //是否输出丢失日志的数量
            if ((isOutDiscardNumber) &amp;&amp; discardCount.incrementAndGet() == discardOutThreshold) {
                discardCount.set(0);
                if (isOutDiscardNumber) {
                    SynchronizingSelfLog.warn(&quot;discarded &quot; + discardOutThreshold + &quot; logs&quot;);
                }
            }

            return false;
        }
    } else {
        // 不允许丢弃则使用next方法
        sequence = ringBuffer.next();
    }

    try {
        SofaTracerSpanEvent event = ringBuffer.get(sequence);
        event.setSofaTracerSpan(sofaTracerSpan);
    } catch (Exception e) {
        SynchronizingSelfLog.error(&quot;fail to add event&quot;);
        return false;
    }
    //发布
    ringBuffer.publish(sequence);
    return true;
}
</code></pre>

<p>SOFATracer 事件发布的调用逻辑：</p>

<p><img src="https://cdn.nlark.com/yuque/0/2020/png/226702/1584325942410-394e84f5-3a86-42ce-8c2d-d4ea204fef42.png" alt="发布调用逻辑" /></p>

<p>追溯调用的流程，可以知道当前 span 调用 finish 时或者 SOFATracer 中调用 reportSpan 时就相当于发布了一个消息事件。</p>

<h2 id="小结">小结</h2>

<p>本文对 SOFATracer 中使用 Disruptor 来进行日志输出的代码进行了简单的分析，更多内部细节原理可以自行看下SOFATracer 的代码。SOFATracer 作为一种比较底层的中间件组件，在实际的业务开发中基本是无法感知的。但是作为技术来学习，还是有很多点可以挖一挖。</p>

<p>SOFATracer：<a href="https://github.com/sofastack/sofa-tracer">https://github.com/sofastack/sofa-tracer</a></p>

<blockquote>
<p>如果有小伙伴对中间件感兴趣，欢迎加入我们团队，欢迎来撩；对 SOFA 技术体系有兴趣的可以关注 <a href="https://www.sofastack.tech/community/">SOFAStack 社区</a>：<a href="https://www.sofastack.tech/community/">https://www.sofastack.tech/community/</a></p>
</blockquote>

</article>

<script>
  const article = document.querySelector('article.typo')
  
  const imgElements = article.querySelectorAll('img');
  
  imgElements.forEach(img => {
    const src = img.getAttribute('src');
    
    
      
    
    img.setAttribute('referrerpolicy', 'no-referrer');
  });
</script>


		<div class="-show-mobile">
			

<nav class="ss-pagination-next">
	<a class="link-prev" href="https://sofastack.github.io/sofastack.tech/blog/sofa-weekly-20200313/">
		<span class="text">上一篇: </span>
		<span class="text">SOFA Weekly | 3/26 直播预告、多个组件发布、云原生团队校招社招信息汇总</span>
	</a>
	<a class="link-next" href="https://sofastack.github.io/sofastack.tech/blog/sofa-ark-maven-packaging-plugins/">
		<span class="text">下一篇: </span>
		<span class="text">蚂蚁金服轻量级类隔离框架 Maven 打包插件解析 | SOFAArk 源码解析</span>
	</a>
</nav>

		</div>
	</main>

	<aside class="ss-layout-aside">
		
		


<div class="ss-card">
	<h2 class="card-title">
		相关推荐
	</h2>
	
	<ul class="ss-aside-related">
		
			<li><a href="/sofastack.tech/blog/sofa-tracer-event-tracing-deep-dive/">蚂蚁金服开源分布式链路跟踪组件 SOFATracer 埋点机制剖析</a></li>
		
			<li><a href="/sofastack.tech/blog/sofa-tracer-overview/">蚂蚁金服分布式链路跟踪组件 SOFATracer 总览|剖析</a></li>
		
			<li><a href="/sofastack.tech/blog/sofa-tracer-response-mechanism/">蚂蚁金服分布式链路跟踪组件 SOFATracer 数据上报机制和源码剖析</a></li>
		
			<li><a href="/sofastack.tech/blog/sofa-tracer-sampling-tracking-deep-dive/">蚂蚁金服开源分布式链路跟踪组件 SOFATracer 采样策略和源码剖析</a></li>
		
			<li><a href="/sofastack.tech/blog/sofa-tracer-unvarnished-transmission-slf4j-mdc/">蚂蚁金服开源分布式链路跟踪组件 SOFATracer 链路透传原理与SLF4J MDC 的扩展能力剖析</a></li>
		
	</ul>
	
</div>

		<div class="ss-aside-tags ss-card">
	<h2 class="card-title">
		标签
		<span class="card-extra"></span>
	</h2>
	<ul class="tag-list">
		
			<li class="tag"><a href="/sofastack.tech/tags/1024/">1024</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/api-gateway/">API Gateway </a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/cafedeployment/">CafeDeployment</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/cloud-native/">Cloud Native</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/cncf/">CNCF</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/db-mesh/">DB Mesh</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/dragonfly/">Dragonfly</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/elasticdl/">ElasticDL</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/http/3/">HTTP/3</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/http/quic/">HTTP/QUIC</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/kata-container/">Kata Container</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/kata-containers/">Kata Containers</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/knative/">Knative</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/kubecon/">KubeCon</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/kubernetes/">Kubernetes</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/meetup/">Meetup</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/mosn/">MOSN</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/nydus/">Nydus</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/occlum/">Occlum</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/rpc-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%80%83%E5%92%8C%E9%87%8F/">RPC 框架设计的考和量</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/seata/">Seata</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/serverless/">Serverless</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/serverlesstask/">ServerlessTask</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/service-mesh/">Service mesh</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/service-mesh-meetup/">Service Mesh Meetup</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/service-mesh-virtual-meetup/">Service Mesh Virtual Meetup</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/service-mesh-webinar/">Service Mesh Webinar</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/service-mesh-%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/">Service Mesh 落地实践</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sidecar-%E5%AE%B9%E5%99%A8/">Sidecar 容器</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofa/">SOFA</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofa-weekly/">SOFA Weekly</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofaacts/">SOFAActs</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofaark/">SOFAArk</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofaarklab/">SOFAArkLab</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofabolt/">SOFABolt</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofaboot/">SOFABoot</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofachannel/">SOFAchannel</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofadashboard/">SOFADashboard</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofaenclave/">SOFAEnclave</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofajraft/">SOFAJRaft</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofajraft-%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90/">SOFAJRaft 特性解析</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofalab/">SOFALab</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofalookout/">SOFALookout</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofameetup/">SOFAMeetup</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofamesh/">SOFAMesh</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofaregistry/">SOFARegistry</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofarpc/">SOFARPC</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofastack/">SOFAStack</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofastack-%E5%BC%80%E6%BA%90%E4%B9%8B%E5%A4%8F/">SOFAStack 开源之夏</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofastak/">SOFAStak</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofatalk/">SOFATalk</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofatracer/">SOFATracer</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/springboot/">SpringBoot</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sqlflow/">SQLFlow</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/summer-2021/">Summer 2021</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/workshop/">Workshop</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/zsearch/">ZSearch</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E4%BD%A0%E7%9A%84%E5%BC%80%E6%BA%90%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/">你的开源入门指南</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">分布式事务</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/">分布式架构</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%89%96%E6%9E%90-sofaark-%E6%BA%90%E7%A0%81/">剖析 | SOFAArk 源码 </a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%89%96%E6%9E%90-sofabolt-%E6%A1%86%E6%9E%B6/">剖析 | SOFABolt 框架</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%89%96%E6%9E%90-sofaboot-%E6%A1%86%E6%9E%B6/">剖析 | SOFABoot 框架</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%89%96%E6%9E%90-sofajraft-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">剖析 | SOFAJRaft 实现原理</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%89%96%E6%9E%90-sofaregistry-%E6%A1%86%E6%9E%B6/">剖析 | SOFARegistry 框架</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%89%96%E6%9E%90-sofarpc-%E6%A1%86%E6%9E%B6/">剖析 | SOFARPC 框架</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%89%96%E6%9E%90-sofatracer-%E6%A1%86%E6%9E%B6/">剖析 | SOFATracer 框架</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%AE%9E%E8%B7%B5/">实践</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%BC%80%E6%BA%90/">开源</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%BC%80%E6%BA%90%E4%B9%8B%E5%A4%8F/">开源之夏</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%BC%80%E6%BA%90%E4%BA%94%E5%91%A8%E5%B9%B4/">开源五周年</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%BC%80%E6%BA%90%E5%85%AD%E5%91%A8%E5%B9%B4/">开源六周年</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%BC%80%E6%BA%90%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%BC%94%E8%BF%9B%E4%B8%8E%E6%9C%AA%E6%9D%A5/">开源容器镜像加速服务的演进与未来</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%BC%B9%E6%80%A7%E4%BC%B8%E7%BC%A9/">弹性伸缩</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E6%96%87%E4%BB%B6%E5%92%8C%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E7%B3%BB%E7%BB%9F/">文件和镜像加速系统</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E6%99%BA%E8%83%BD%E7%9B%91%E6%8E%A7/">智能监控</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E6%99%BA%E8%83%BD%E8%BF%90%E7%BB%B4/">智能运维</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E6%BA%90%E5%88%9B%E4%BC%9A/">源创会</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">源码解析</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E7%B1%BB%E9%9A%94%E7%A6%BB%E6%A1%86%E6%9E%B6/">类隔离框架</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E9%95%9C%E5%83%8F/">镜像</a></li>
		
	</ul>
</div>
	</aside>
</div>



	


<footer class="ss-footer">
	<div class="container">
		<div class="links">
			
				<div class="cate">
					<h2 class="cate-title">资源</h2>
					
						<a class="link" href="https://github.com/sofastack">Github</a>
					
						<a class="link" href="https://gitee.com/sofastack/">Gitee</a>
					
						<a class="link" href="https://github.com/sofastack-guides">示例</a>
					
				</div>
			
				<div class="cate">
					<h2 class="cate-title">社交媒体</h2>
					
						<a class="link" href="https://zhuanlan.zhihu.com/sofastack">知乎专栏</a>
					
						<a class="link" href="https://weibo.com/sofastack">新浪微博</a>
					
						<a class="link" href="https://twitter.com/sofastack_io">Twitter</a>
					
				</div>
			
				<div class="cate">
					<h2 class="cate-title">参与进来</h2>
					
						<a class="link" href="https://github.com/sofastack/sofastack.tech/issues/new">反馈</a>
					
						<a class="link" href="https://github.com/sofastack/community">社区</a>
					
						<a class="link" href="https://github.com/sofastack/sofastack.tech/wiki">Wiki</a>
					
						<a class="link" href="mailto:sofa@alipay.cloud.com">Email</a>
					
						<a class="link" href="/hr/">加入我们</a>
					
				</div>
			
				<div class="cate">
					<h2 class="cate-title">蚂蚁集团开源项目</h2>
					
						<a class="link" href="https://ant.design/">Ant Design</a>
					
						<a class="link" href="https://eggjs.org/">Egg </a>
					
						<a class="link" href="https://sqlflow.org">SQLFlow</a>
					
						<a class="link" href="https://tech.antfin.com/open-source">更多</a>
					
				</div>
			
		</div>
		<div class="qrcode">
			
				<div>
					<img class="qrcode-img" src="/sofastack.tech/img/qrcode/qrcode_video_2024.jpg" />
					<p class="qrcode-desc">微信视频号</p>
				</div>
			
				<div>
					<img class="qrcode-img" src="/sofastack.tech/img/qrcode/qrcode_1_2024.jpg" />
					<p class="qrcode-desc">微信公众号</p>
				</div>
			
				<div>
					<img class="qrcode-img" src="/sofastack.tech/img/qrcode/dingtalk_7.jpg" />
					<p class="qrcode-desc">钉钉群</p>
				</div>
			
		</div>
	</div>
	<div class="copyright">
		<p>
			© 2018 - 2022  The SOFAStack Authors
			<a href="http://beian.miit.gov.cn/">浙 ICP 备 16045294 号-3</a>
		</p>
	</div>
</footer>

</body>

</html>