<!DOCTYPE html>
<html>

<head>
	<title>
	Nydus | 容器镜像基础 · SOFAStack
</title>
	<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="SOFAStack is a Scalable Open Financial Architecture for building cloud native applications" />

<meta name="generator" content="Hugo 0.55.5" /><link rel="shortcut icon" href=https://img.alicdn.com/imgextra/i3/O1CN019CRHyf1qyMghfS3id_!!6000000005564-2-tps-211-128.png type="image/png">

<link href="https://unpkg.com/purecss@1.0.0/build/base-min.css" rel="stylesheet">



<link href="/sofastack.tech/css/main.css" rel="stylesheet">
<link href="/sofastack.tech/css/zoom-image.css" rel="stylesheet">

<script src="/sofastack.tech/js/iconfont.js"></script>
<script src="/sofastack.tech/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<script>window.SITE_LANGUAGE = "zh"</script>
<script src="/sofastack.tech/js/app.js"></script>





<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-142131411-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</head>

<body>
	<header class="ss-header">
	<nav class="navbar" role="navigation" aria-label="main navigation">
		<div class="navbar-brand">
			<a class="logo-link" href="/sofastack.tech/">
				<img class="logo" src="/sofastack.tech/img/logo-2024.png">
			</a>
			<div class="-show-mobile">
				<a id="mobile-menu-icon">
					<svg class="icon" aria-hidden="true">
						<use xlink:href="#icon-menu"></use>
					</svg>
				</a>
				<nav id="mobile-menu">
						<div id="js-menu-search-mobile" class="navbar-search-mobile">
							<input class="input" placeholder="请输入要搜索的关键词">
							<svg class="icon" aria-hidden="true">
								<use xlink:href="#icon-search"></use>
							</svg>
						</div>
					
          
            <a
              class=""
              href="/sofastack.tech/projects/">
              <span>
                项目
              </span>
              <svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"></use></svg>
            </a>
					
            <a
              class=""
              href="/sofastack.tech/guides/">
              <span>
                指南
              </span>
              <svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"></use></svg>
            </a>
					
            <a
              class=""
              href="/sofastack.tech/blog/">
              <span>
                博客
              </span>
              <svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"></use></svg>
            </a>
					
            <a
              class=""
              href="/sofastack.tech/activities/">
              <span>
                活动
              </span>
              <svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"></use></svg>
            </a>
					
            <a
              class=""
              href="/sofastack.tech/community/">
              <span>
                社区
              </span>
              <svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"></use></svg>
            </a>
					
            <a
              class=""
              href="/sofastack.tech/awesome/">
              <span>
                Awesome SOFA
              </span>
              <svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"></use></svg>
            </a>
					
					
				</nav>
			</div>
		</div>

		<div class="navbar-menu -hidden-mobile">
			<div class="navbar-start">
				
				
					<a class="navbar-item "
						href="/sofastack.tech/projects/">项目</a>
				
					<a class="navbar-item "
						href="/sofastack.tech/guides/">指南</a>
				
					<a class="navbar-item "
						href="/sofastack.tech/blog/">博客</a>
				
					<a class="navbar-item "
						href="/sofastack.tech/activities/">活动</a>
				
					<a class="navbar-item "
						href="/sofastack.tech/community/">社区</a>
				
					<a class="navbar-item "
						href="/sofastack.tech/awesome/">Awesome SOFA</a>
				
			</div>
			<div class="navbar-end">
				<div class="navbar-item">
					<div id="js-menu-search" class="navbar-search">
						<input class="input" placeholder="请输入要搜索的关键词">
						<svg class="icon" aria-hidden="true">
							<use xlink:href="#icon-search"></use>
						</svg>
					</div>
				</div>
				<div class="navbar-item">
					
				</div>
			</div>
		</div>
	</nav>
</header>


	

	

	

	

	

	



	

<div class="ss-layout-container">
	<main class="ss-layout-main -card">
		<div class="ss-meta">
	<h1 class="title">
		Nydus | 容器镜像基础
	</h1>
	<div class="meta">
		
			2022-11-09 ·
			
				<a href="https://github.com/sofastack"></a> ·
			
			<span class="tags">
				
					<a class="tag" href="/sofastack.tech/tags/sofastack/" rel="tag">#SOFAStack</a>
				
			</span>
		
	</div>
</div>
		<article class="typo">
  <p>文｜唐斌</p>

<p>字节跳动基础架构研发工程师</p>

<p>Nydus 与 Nydus snapshotter 社区贡献者，专注存储，云原生技术。</p>

<p>本文 <strong>6964</strong> 字 阅读 <strong>15</strong> 分钟</p>

<hr />

<h2 id="1-nydus">1 Nydus</h2>

<h3 id="1-1-存在的问题">1.1 存在的问题</h3>

<p><strong>对于容器镜像使用者</strong></p>

<p><strong>问题一：</strong> 启动容器慢：容器启动慢的情况普遍发生在当用户启动一个很大的容器镜像时，由于在容器准备阶段需要三步（以 overlayfs 为例）：</p>

<p><strong>-</strong> 下载镜像；</p>

<p><strong>-</strong> 解压镜像；</p>

<p><strong>-</strong> 使用 overlayfs 将容器可写层和镜像中的只读层聚合起来提供容器运行环境。</p>

<p>其中，下载镜像阶段需要下载整个镜像文件，不能实现文件数据按需加载。再加上下载镜像本身受限于网络带宽，当容器镜像达到 GB 级别时，下载时间会较长，破坏了容器原本优秀的用户体验。</p>

<p><strong>问题二：</strong> 较高的本地存储成本：不同镜像之间可以共享的最小单位是镜像中的层，缺点之一是重复数据的处理效率较低。</p>

<p>原因如下：</p>

<p><strong>-</strong> 首先，层内部存在重复的数据；</p>

<p><strong>-</strong> 其次，层与层之间可能存在大量重复的数据，即使有微小的差别，也会被作为不同的层；</p>

<p><strong>-</strong> 再次，根据 OCI imagespec 对删除文件和 hardlink 的设计，镜像内部已经被上层删除的文件可能仍然存在于下层，并包含在镜像中。</p>

<p><strong>对于镜像提供者</strong></p>

<p>这里的提供者主要指容器服务的镜像中心。</p>

<p><strong>问题一：</strong> 巨大的存储资源浪费。</p>

<p><strong>-</strong> <strong>存在大量相似镜像，造成这种情况有两个原因：</strong></p>

<ul>
<li><p>首先，上面提到的层的缺点，导致在容器镜像中心存在许多相似镜像；</p></li>

<li><p>其次，OCI image 使用了 tar+gzip 格式来表示镜像中的层，而 tar 格式并不区分 tar archive entries ordering，这带来一个问题，如果用户在不同机器上 build 同一个镜像，最终可能会因为使用了不同的文件系统而得到不同的镜像，用户上传之后，镜像中心中会存在若干不同镜像的实质内容是完全相同的情况。</p></li>
</ul>

<p><strong>- 镜像去重效率低</strong></p>

<p>虽然镜像中心有垃圾回收机制来实现去重功能，但其仍然以层为单位，所以只能在有完全相同 hash value 的层之间去重。</p>

<p><strong>问题二：</strong> 云原生软件供应链带来的新需求。</p>

<p>随着时间推移，和软件供应链一起发展的还有对软件供应链环节的多样性攻击手段。安全防护是软件供应链中非常重要的组成，不光体现在对软件本身的安全增强，也体现在对供应链的安全增强。因为应用运行环境被前置到了容器镜像中，所以对容器镜像的安全，包括对镜像的漏洞扫描和签名成为了容器服务提供者的必要能力。</p>

<p><strong>OCI 镜像规范的缺陷</strong></p>

<p>主要的缺陷有两点：</p>

<p><strong>- tar 格式标准</strong></p>

<ul>
<li><p>tar 格式并不区分 tar archive entries ordering，这带来一个问题，即如果用户在不同机器上 ；build 同一个镜像，最终可能会因为使用了不同的文件系统而得到不同的镜像，比如在文件系统 A 上的 order 是 foo 在 bar 之前进入 tar ，在文件系统 B 上的 order 是 bar 在 foo 之前进入tar ，那么这两个镜像是不同的；</p></li>

<li><p>当 tar 被 gzip 压缩过之后不支持 seek ，导致运行之前必须先下载并解压 targz 的 image layers，而不能实现文件数据按需加载。</p></li>
</ul>

<p><strong>- 以层为镜像的基本单位</strong></p>

<ul>
<li><p>内容冗余：不同层之间相同信息在传输和存储时都是冗余内容，在不读取内容的时候无法判断到这些冗余的存在；</p></li>

<li><p>无法并行：每一层是一个整体，对同一个层既无法并行传输，也不能并行提取；</p></li>

<li><p>无法进行小块数据的校验，只有完整的层下载完成之后，才能对整个层的数据做完整性校验；</p></li>

<li><p>其他一些问题：比如，跨层数据删除难以完美处理。</p></li>
</ul>

<h3 id="1-2-nydus-基础">1.2 Nydus 基础</h3>

<p>在容器的生产实践中，偏小的容器镜像能够很快部署启动。当应用的镜像达到 GB 级以上的时候，在节点上下载镜像通常会消耗大量的时间。Dragonfly 通过引入 P2P 网络有效地提升了容器镜像大规模分发的效率。然而，用户必须等待镜像数据完整下载到本地，然后才能创建自己的容器。</p>

<p>Nydus 是在最新的 OCI Image-Spec 基础之上设计的容器镜像加速服务，重新设计了镜像格式和底层文件系统，从而加速容器启动速度，提高大规模集群中的容器启动成功率。Nydus 由阿里云和蚂蚁集团的工程师合作开发，并大规模部署在内部的 生产环境中。</p>

<p>Nydus 优化了现有的 OCI 镜像标准格式，并以此设计了一个用户态的文件系统。通过这些优化，Nydus 能够提供这些特性：</p>

<ul>
<li><p>容器镜像按需下载，用户不再需要下载完整镜像就能启动容器</p></li>

<li><p>块级别的镜像数据去重，最大限度为用户节省存储资源</p></li>

<li><p>镜像只有最终可用的数据，不需要保存和下载过期数据</p></li>

<li><p>端到端的数据一致性校验，为用户提供更好的数据保护</p></li>

<li><p>兼容 OCI 分发标准和 artifacts 标准，开箱即可用</p></li>
</ul>

<p>支持不同的镜像存储后端，镜像数据不只可以存放在镜像仓库，还可以放到 NAS 或者类似 S3 的对象存储上</p>

<ul>
<li>与 Dragonfly 的良好集成</li>
</ul>

<h3 id="1-3-nydus-架构">1.3 Nydus 架构</h3>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5503e590f504aaaa3bc42f80ac0ba29~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" /></p>

<p>Nydus 的架构主要包含两部分内容：</p>

<p><strong>- 新的镜像格式（Rafs）</strong></p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b83352225c1449f2bb9ed1eb84bc9c47~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" /></p>

<p><strong>- 负责解析容器镜像的 FUSE 用户态文件系统进程</strong></p>

<p>Nydus 兼容多种文件系统，能够解析 FUSE 和 virtiofs 协议来支持传统的 runc 容器、 Kata容器。对于存储后端，支持使用容器仓库（ Registery ）、OSS 对象存储 、NAS、Dragonfly 的超级节点和 Peer 节点作为 Nydus 的镜像数据存储后端。此外，为了加速启动速度，Nydus 还可以配置一个本地缓存，避免每次启动容器时都从远端数据源拉取数据。</p>

<h3 id="1-4-nydus-特性">1.4 Nydus 特性</h3>

<p><strong>容器启动速度变快</strong></p>

<p>用户部署了 Nydus 镜像服务后，由于使用了按需加载镜像数据的特性，容器的启动时间明显缩短。在官网的测试数据中，Nydus 能够把常见镜像的启动时间，从数分钟缩短到数秒钟。理论上来说，容器镜像越大，Nydus 体现出来的效果越明显。</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a10475df4ec04aa9807279000e84dcae~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" /></p>

<p><strong>提供运行时数据一致校验</strong></p>

<p>在传统的镜像中，镜像数据会先被解压到本地文件系统，再由容器应用去访问使用。解压前，镜像数据是完整校验的。但是解压之后，镜像数据不再能够被校验。这带来的一个问题就是，如果解压后的镜像数据被无意或者恶意地修改， 用户是无法感知的。而 Nydus 镜像不会被解压到本地，同时可以对每一次数据访问进行校验，如果数据被篡改，则可以从远端数据源重新拉取。</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dfd14c9369f4bf7a59421a45e04c1e4~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" /></p>

<p>从图中可以看出，对容器镜像数据进行运行时一致性校验是通过对每个数据块计算 SHA 256 实现的，这得益于 Nydus 采用分块的方式管理镜像数据。如果在镜像文件非常大的时候，对整个镜像文件计算哈希值非常不现实。</p>

<h3 id="1-5-nydus-镜像格式-rafs">1.5 Nydus 镜像格式：RAFS</h3>

<p>RAFS 是对 EROFS 文件系统的增强，拓展在云原生场景下的能力，使其适应容器镜像存储场景。RAFS v6 是内核态的容器镜像格式，除了将镜像格式下沉到内核态，还在镜像格式上进行了一系列优化，例如块对齐、更加精简的元数据等。</p>

<p><strong>RAFS v6 镜像格式</strong></p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33307b9e5f8746e29071091ba034b866~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" /></p>

<h3 id="1-6-nydus-snapshotter">1.6 Nydus -snapshotter</h3>

<p>Nydus snapshotter 是 containerd 的一个外部插件，使得 containerd 能够使用 Nydus 镜像加速服务。在 containerd 中， snapshot 的工作是给容器提供 rootfs，Nydus snapshotter 实现了 containerd 的 snapshot 的接口，使得 containerd 可以通过 Nydus 准备 rootfs 以启动容器。由于 nydus-snapshotter 实现了按需加载的特性，在 containerd 启动容器时，只需要根据容器镜像的元数据信息准备 rootfs ，部分目录对应的数据并未存储在本地，当在容器中访问到（本地访问未命中）这部分数据时，通过 Nydusd 从镜像 registry 拉取对应数据内容。</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90bbf50038494c83af3fc17c59a24714~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" /></p>

<h2 id="02-fuse">02 FUSE</h2>

<p>用户态文件系统（ filesystem in userspace， 简称 FUSE ）使得用户无需修改内核代码就能创建自定义的文件系统。FUSRE 催生了著名的 fuse-overlayfs，其在 rootless 容器化中扮演重要的角色。</p>

<p>用户态文件系统并不完全在用户态实现，由两部分组成：内核模块和用户态进程。</p>

<ul>
<li><p>内核模块：文件系统数据流程的功能实现，负责截获文件访问请求和返回用户态进程处理请求的结果</p></li>

<li><p>用户态进程：负责处理具体的数据请求，对应处理函数由内核模块触发</p></li>
</ul>

<p>FUSE 的工作流程如下图：</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82bbd988241949aca91b65c7df4dc9bb~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" /></p>

<p>其中，fuse_user 是运行在用户态的文件系统进程，该程序会在启动时注册实现的数据请求处理接口，如 ls 、cd 、mkdir 等，同时，程序在某个路径挂载 fuse 文件系统 /tmp/fuse_fs ，当对 /tmp/fuse_fs 执行相关操作时：</p>

<ul>
<li><p>请求会经过 VFS（虚拟文件系统） 到达 fuse 的内核模块</p></li>

<li><p>内核模块根据请求类型，调用用户态进程注册的函数</p></li>

<li><p>当程序完成对请求的处理后，将结果通过 VFS 返回给系统调用</p></li>
</ul>

<h2 id="03-containerd">03 Containerd</h2>

<p>Containerd 最开始是 Docker Engine 中的一部分，后来，containerd 被分离出来作为独立的开源项目，目标是提供更开放、稳定的容器运行基础设施。分离出来的 containerd 将具有更多的功能，涵盖整个容器运行时管理的所有需求。</p>

<p>Containerd 是一个行业标准的容器运行时，强调简单性、健壮性和可移植性，可以作为守护进程运行在系统中。</p>

<p>Containerd 的功能主要包括以下内容：</p>

<ul>
<li><p>管理容器的生命周期（从创建容器到销毁容器）</p></li>

<li><p>拉取/推送容器镜像</p></li>

<li><p>存储管理（管理镜像及容器数据的存储）</p></li>

<li><p>调用 runc 运行容器（与 runc 等容器运行时交互）</p></li>

<li><p>管理容器网络接口及网络</p></li>
</ul>

<p>Containerd 采用 C/S 架构，服务端通过 unix domain socket 暴露低层 gRPC 接口，客户端通过这些 gRPC 接口管理节点上的容器，containerd 负责管理容器的镜像、生命周期、网络和存储，实际运行容器是由容器运行时（runc 是其中一种）完成。</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8764fa487d274aebbb131c1ac3e152a3~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" /></p>

<p>Containerd 将系统划分成不同的组件，每个组件由一个或多个模块协作完成（Core 部分），不同模块都以插件的形式集成到 containerd 中，插件之间相互依赖。</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dab409fe3770449f82172f1b6eb6e69f~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" /></p>

<p>Containerd 的组件可以分成三类：Storage、Metadata 和 Runtimes，snapshot 属于 Storage 组件中的一个插件，用来管理容器镜像的文件系统快照，镜像中的每一层都会被解压成文件系统快照。在使用 Nydus 的 containerd 环境中，Nydus-snapshotter 负责完成这部分工作。</p>

<h2 id="04-erofs-fsache">04 Erofs + fsache</h2>

<p><strong>Erofs over fscache 基本概念</strong></p>

<p>Erofs over fscache 是 Linux 内核原生的镜像按需加载特性，于 5.19 版本合入 Linux 内核主线。</p>

<p>已有的用户态方案会涉及频繁的内核态/用户态上下文切换，以及内核态/用户态之间的内存拷贝，从而造成性能瓶颈。这一问题在容器镜像已经全部下载到本地的时候尤其突出，容器运行过程中涉及的文件访问，都会陷出到用户态的服务进程。</p>

<p>事实上我们可以将按需加载的</p>

<p>（1）缓存管理和</p>

<p>（2）缓存未命中的时候通过各种途径 (例如网络) 获取数据，这两个操作解耦开。缓存管理可以下沉到内核态执行，这样当镜像在本地 ready 的时候，就可以避免内核态/用户态上下文的切换。而这也正是 erofs over fscache 技术的价值所在。</p>

<p>fscache/cachefiles  (以下统称 fscache ) 是 Linux 系统中相对成熟的文件缓存方案，广泛应用于网络文件系统，erofs over fscache 技术使得 fsache 能够支持 erofs 的按需加载特性。</p>

<p>容器在访问容器镜像的时候，fscache 会检查当前请求的数据是否已经缓存，如果缓存命中 ( cache hit )，那么直接从缓存文件读取数据。这一过程全程处于内核态之中，并不会陷出到用户态。</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a58a7d6051ba4219ad4f101cb9fb8d9d~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" /></p>

<p>缓存未命中 ( cache miss )时 需要通知用户态的 Nydusd 进程以处理这一访问请求，此时容器进程会陷入睡眠等待状态；Nydusd 通过网络从远端获取数据，通过 fscache 将这些数据写入对应的缓存文件，之后通知之前陷入睡眠等待状态的进程该请求已经处理完成；之后容器进程即可从缓存文件读取到数据。</p>

<p><strong>Erofs over fscache 优势</strong></p>

<p><strong>- 异步预取</strong></p>

<p>容器创建之后，当容器进程尚未触发按需加载 (cache miss) 的时候，用户态的 Nydusd 就可以开始从网络下载数据并写入缓存文件，之后当容器访问的文件位置恰好处于预取范围内的时候，就会触发 cache hit 直接从缓存文件读取数据，而不会再陷出到用户态。用户态方案则无法实现该优化。</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edc7f3c7d4e24d9ba73cca565213e40c~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" /></p>

<p><strong>- 网络 IO 优化</strong></p>

<p>当触发按需加载 (cache miss) 时，Nydusd 可以一次性从网络下载比当前实际请求的数据量更多的数据，并将下载的数据写入缓存文件。例如容器访问 4K 数据触发的 cache miss，而 Nydusd 实际一次性下载 1MB 数据，以减小单位文件大小的网络传输延时。之后容器访问接下来的这 1MB 数据的时候，就<strong>不必再陷出到用户态</strong>。</p>

<p>用户态方案则无法实现该优化，因为即使触发 cache miss 的时候，用户态的服务进程同样实现了该优化，下一次容器访问位于读放大范围内的文件数据的时候，同样会陷出到用户态。</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab51a57b66ac40e7b308fa90a80da897~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" /></p>

<p><strong>- 更佳的性能表现</strong></p>

<p>当镜像数据已经全部下载到本地的时候 (即不考虑按需加载的影响)， erofs over fscache 的性能表现显著优于用户态方案，同时与原生文件系统的性能相近，从而实现与原生容器镜像方案 (未实现按需加载) 相近的性能表现。</p>

<h2 id="05-环境安装">05 环境安装</h2>

<p><strong>nerdctl 安装</strong></p>

<pre><code class="language-rust"># git clone https://github.com/rootless-containers/rootlesskit.git
# cd rootlesskit
# make &amp;&amp; sudo make install
wget https://github.com/containerd/nerdctl/releases/download/v0.22.2/nerdctl-full-0.22.2-linux-amd64.tar.gz
sudo tar -zxvf nerdctl-full-0.22.2-linux-amd64.tar.gz -C /usr/local
sudo systemctl enable --now containerd
sudo systemctl enable --now buildkit
# sudo apt-get install uidmap -y
# containerd-rootless-setuptool.sh install
sudo nerdctl version    # 需要使用sudo，不然会提示安装 rootless
</code></pre>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5ccc931c8b4468d9e9ea47bf405097c~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" /></p>

<p><strong>Nydus 安装</strong></p>

<p>装主要的3个工具（也可以直接下载所有工具的二进制文件，编译安装时默认没有没有 Nydusify ）：</p>

<ul>
<li><p><code>nydusify</code> 将 OCI 格式的容器镜像转换为 Nydus 格式（ RAFS ）容器镜像的工具。</p></li>

<li><p><code>nydus-image</code>将解压后的容器镜像转换为 Nydus 格式镜像的工具。</p></li>

<li><p><code>nydusd</code> 解析 Nydus 格式镜像并提供 FUSE 挂载点以供容器访问的守护程序。<code>nydusd</code> 也可以用作 virtiofs 后端，使得 Guest 可以访问 Host 的文件。</p></li>
</ul>

<pre><code class="language-rust">git clone https://github.com/dragonflyoss/image-service.git
cd image-service
make &amp;&amp; make install
# 默认没有安装 nydusify
wget https://github.com/dragonflyoss/image-service/releases/download/v2.1.0-rc.1/nydus-static-v2.1.0-rc.1-linux-amd64.tgz
mkdir nydus-static
tar -zxvf nydus-static-v2.1.0-rc.1-linux-amd64.tgz -C nydus-static
sudo cp nydus-static/nydusify /usr/local/bin
sudo cp nydus-static/nydus-overlayfs /usr/local/bin
nydus-image --version
nydusify --version
nydusd --version
</code></pre>

<p><strong>安装 Nydus-snapshotter</strong></p>

<pre><code class="language-rust">git clone github.com/containerd/nydus-snapshotter.git
cd nydus-snapshotter
make &amp;&amp; make install
sudo systemctl enable nydus-snapshotter
sudo systemctl start nydus-snapshotter
systemctl status nydus-snapshotter
</code></pre>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6265954c8784483d812548844f7e2e6d~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" /></p>

<p>Nydus-snapshotter 以 service 的形式运行 /usr/local/bin/containerd-nydus-grpc 可执行文件，配置信息位于 /etc/nydus/config.json 文件。</p>

<p>默认 address 位置：</p>

<p>/run/containerd-nydus/containerd-nydus-grpc.sock</p>

<p>默认工作目录：</p>

<p>/var/lib/containerd-nydus-grpc</p>

<p>默认缓存目录：</p>

<p>/var/lib/containerd-nydus-grpc/cache</p>

<p><strong>部署本地镜像仓库（测试用）</strong></p>

<pre><code class="language-rust"># sudo docker run -d -p 5000:5000 \
# --restart=always \
# --name registry \
# -v /var/lib/registry:/var/lib/registry \
# -d registry
sudo docker run -d --name=registry --restart=always -p 5000:5000 registry
sudo docker logs registry -f
</code></pre>

<p><strong>将 OCI 格式的镜像转换为 RAFS 格式镜像</strong></p>

<pre><code class="language-rust">sudo nydusify convert \
  --nydus-image $(which nydus-image) \
  --source ubuntu:16.04 \
  --target localhost:5000/ubuntu:16.04-nydus
</code></pre>

<p>Nydusify 基本命令：</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae6a97362cf64cc8bef438970e74e1b3~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" /></p>

<p>转换后的镜像层文件位于当前目录下的 tmp 文件夹：</p>

<pre><code class="language-rust">sudo tree tmp -L 4
</code></pre>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/369fad74865b45659f6473d8239340a0~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" /></p>

<p>将 OCI 标准的镜像格式转换为 Nydus 使用的 RAFS 镜像格式后，可以使用 Nydusd 解析并提供 fuse 挂载点供容器使用。编写配置文件 registry.json，使得 Nydus 使用 容器镜像 registry （已经搭建本地容器镜像 register 用于测试）作为存储后端。</p>

<pre><code class="language-rust">{
  &quot;device&quot;: {
    &quot;backend&quot;: {
      &quot;type&quot;: &quot;registry&quot;,
      &quot;config&quot;: {
        &quot;scheme&quot;: &quot;http&quot;,
        &quot;host&quot;: &quot;localhost:5000&quot;,
        &quot;repo&quot;: &quot;ubuntu&quot;
      }
    },
    &quot;digest_validate&quot;: false
  },
  &quot;mode&quot;: &quot;direct&quot;
}
</code></pre>

<p>挂载  RAFS 镜像 为 fuse 挂载点，&ndash;bootstrap 参数传递位于 tmp/bootstraps 下的文件路径：</p>

<pre><code class="language-rust">sudo nydusd \
  --config ./registry.json \
  --mountpoint /mnt \
  --bootstrap ./tmp/bootstraps/4-sha256:fb15d46c38dcd1ea0b1990006c3366ecd10c79d374f341687eb2cb23a2c8672e \
  --log-level info
</code></pre>

<p>查看挂载情况：</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/142cb2d18c2246b1b740f482ffc893ed~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" /></p>

<p>输出日志信息：</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a08490e7e6364e64bbb93b7201cae64d~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" /></p>

<p>除了使用 Nydusify 直接将 OCI 标准格式镜像转换为 Nydus 格式镜像，Nydus-image 工具也支持直接对已经解压的 OCI 容器镜像文件层转换为 Nydus 格式镜像。</p>

<p><strong>（1）获取 OCI 镜像元数据信息：</strong></p>

<pre><code class="language-rust">docker pull ubuntu:16.04
sudo docker inspect -f &quot;{{json .GraphDriver }}&quot; ubuntu:16.04  | jq .
</code></pre>

<p>Docker 使用 overlay2 存储驱动，通过所需的 lowerdir 、upperdir 、merged 和 workdir 结构自动创建 overlay 挂载点。</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f8d1bad88df47a1851c6ee12f174ef1~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" /></p>

<p>对于 Nydus 来说，目录树（通常是一个镜像层）由两部分组成：</p>

<ul>
<li><p>bootstrap：存储目录的文件系统元数据信息</p></li>

<li><p>blob：存储目录中的所有文件数据</p></li>
</ul>

<p><strong>（2）建立生成 Nydus 镜像的目录：</strong></p>

<pre><code class="language-rust">mkdir -p nydus-image/{blobs,layer1,layer2,layer3,layer4}
</code></pre>

<p><strong>（3）转换最底层的镜像层：</strong></p>

<pre><code class="language-rust">sudo nydus-image create \
  --bootstrap ./nydus-image/layer1/bootstrap \
  --blob-dir ./nydus-image/blobs \
  --compressor none /var/lib/docker/overlay2/78f2b3506072c95ca3929a0a797c1819e8966b8bbf5ce8427b671296ca1ad35a/diff
tree -L 2 ./nydus-image
</code></pre>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e97e15adc12424e830fbf223fd11c73~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" /></p>

<p><strong>（4）转换第 2 底层镜像层，&ndash;parent-bootstrap 指父层，即刚才转换好的镜像层：</strong></p>

<pre><code class="language-rust">sudo nydus-image create \
  --parent-bootstrap ./nydus-image/layer1/bootstrap \
  --bootstrap ./nydus-image/layer2/bootstrap \
  --blob-dir ./nydus-image/blobs \
  --compressor none /var/lib/docker/overlay2/373ea430abb0edd549583f949ec8259806d9eb7d0a0416ec1494d2fc7efeeedc/diff
</code></pre>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45140d9871cb4c2eb99a221fad6e265b~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" /></p>

<p><strong>（5）转换第 3 层和第 4 层，每次都需要指定 &ndash;parent-bootstrap 为上一次生成的镜像层：</strong></p>

<pre><code class="language-rust">sudo nydus-image create \
  --parent-bootstrap ./nydus-image/layer2/bootstrap \
  --bootstrap ./nydus-image/layer3/bootstrap \
  --blob-dir ./nydus-image/blobs \
  --compressor none /var/lib/docker/overlay2/05424b8c067c59368c11ad5674d68d95365e87487bdf10e3d9842b1016583369/diff
sudo nydus-image create \
  --parent-bootstrap ./nydus-image/layer3/bootstrap \
  --bootstrap ./nydus-image/layer4/bootstrap \
  --blob-dir ./nydus-image/blobs \
  --compressor none /var/lib/docker/overlay2/942c712e7276be5bde4fb7b30f72583c4a9cf0b2aaa14215cd690daf893a630e/diff
</code></pre>

<p>将 Nydus 镜像挂载到目录：</p>

<pre><code class="language-rust">sudo nydusd \
  --config  ./localfs.json \
  --mountpoint /mnt \
  --bootstrap ./nydus-image/layer4/bootstrap \
  --log-level info
</code></pre>

<p>其中， localfs.json 文件的内容为：</p>

<pre><code class="language-rust">{
  &quot;device&quot;: {
    &quot;backend&quot;: {
      &quot;type&quot;: &quot;localfs&quot;,
      &quot;config&quot;: {
        &quot;dir&quot;: &quot;/&lt;YOUR-WORK-PATH&gt;/nydus-image/blobs&quot;
      }
    }
  },
  &quot;mode&quot;: &quot;direct&quot;
}
</code></pre>

<p>Dir 为生成的 Nydus 镜像文件中 blobs 目录的绝对路径。</p>

<h2 id="06-通过-nydus-snapshotter-启动容器">06 通过 Nydus+snapshotter 启动容器</h2>

<p><strong>添加配置文件</strong></p>

<p>Nydus 提供了 containerd 远程快照管理工具 containerd-nydus-grpc 用于准备 Nydus 镜像格式的容器 rootfs ，首先将 Nydusd 配置保存到  /etc/nydus/config.json 文件。</p>

<pre><code class="language-rust">sudo tee /etc/nydus/config.json &gt; /dev/null &lt;&lt; EOF
{
  &quot;device&quot;: {
    &quot;backend&quot;: {
      &quot;type&quot;: &quot;registry&quot;,
      &quot;config&quot;: {
        &quot;scheme&quot;: &quot;http&quot;,
        &quot;skip_verify&quot;: false,
        &quot;timeout&quot;: 5,
        &quot;connect_timeout&quot;: 5,
        &quot;retry_limit&quot;: 2,
        &quot;auth&quot;: &quot;&quot;
      }
    },
    &quot;cache&quot;: {
      &quot;type&quot;: &quot;blobcache&quot;,
      &quot;config&quot;: {
        &quot;work_dir&quot;: &quot;cache&quot;
      }
    }
  },
  &quot;mode&quot;: &quot;direct&quot;,
  &quot;digest_validate&quot;: false,
  &quot;iostats_files&quot;: false,
  &quot;enable_xattr&quot;: true,
  &quot;fs_prefetch&quot;: {
    &quot;enable&quot;: true,
    &quot;threads_count&quot;: 4
  }
}
EOF
</code></pre>

<p>containerd-nydus-grpc 会自动从 $HOME/.docker/config.json 中读取 docker login auth ，如果不想使用这个值，需要直接替换配置文件中的内容。</p>

<p>直接从终端启动 containerd-nydus-grpc，如果已经通过 containerd-nydus-grpc service 启动，则可以跳过此步骤：</p>

<pre><code class="language-rust">sudo /usr/local/bin/containerd-nydus-grpc \
    --config-path /etc/nydus/config.json \
    --shared-daemon \
    --log-level info \
    --root /var/lib/containerd/io.containerd.snapshotter.v1.nydus \
    --cache-dir /var/lib/nydus/cache \
    --address /run/containerd-nydus/containerd-nydus-grpc.sock \
    --nydusd-path /usr/local/bin/nydusd \
    --nydusimg-path /usr/local/bin/nydus-image \
    --log-to-stdout
</code></pre>

<p><strong>修改 containerd 配置文件</strong></p>

<p>proxy_plugins.nydus 的 address 和 containerd-nydus-grpc 的对应。</p>

<pre><code class="language-rust">sudo tee -a /etc/containerd/config.toml &lt;&lt; EOF
[proxy_plugins]
  [proxy_plugins.nydus]
    type = &quot;snapshot&quot;
    address = &quot;/run/containerd-nydus/containerd-nydus-grpc.sock&quot;
[plugins.cri]
  [plugins.cri.containerd]
    snapshotter = &quot;nydus&quot;
    disable_snapshot_annotations = false
EOF
sudo systemctl restart containerd
sudo ctr -a /run/containerd/containerd.sock plugin ls | grep nydus
</code></pre>

<p><strong>通过 Nydus 启动容器</strong></p>

<pre><code class="language-rust"># 转换镜像并上传到本地 registry
sudo nydusify convert --nydus-image /usr/local/bin/nydus-image --source ubuntu --target localhost:5000/ubuntu-nydus
sudo nerdctl --snapshotter nydus pull localhost:5000/ubuntu-nydus:latest
sudo nerdctl --snapshotter nydus run --rm -it localhost:5000/ubuntu-nydus:latest bash
</code></pre>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91871b2863ab489e9dbc595364dda254~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" /></p>

<p><strong>重启主机之后启动环境</strong></p>

<pre><code class="language-rust">sudo systemctl restart nydus-snapshotter
sudo systemctl restart containerd
sudo docker rm -f registry
sudo docker run -d --name=registry --restart=always -p 5000:5000 registry &amp;&amp; sudo docker logs registry -f
</code></pre>

<h2 id="07参考资料">07参考资料</h2>

<p>[1]OCI 镜像标准格式:
<em><a href="https://github.com/opencontainers/image-spec">https://github.com/opencontainers/image-spec</a></em></p>

<p>[2]自校验的哈希树:
<em><a href="https://en.wikipedia.org/wiki/Merkle_tree">https://en.wikipedia.org/wiki/Merkle_tree</a></em></p>

<p>[3]FUSE:
<em><a href="https://www.kernel.org/doc/html/latest/filesystems/fuse.html">https://www.kernel.org/doc/html/latest/filesystems/fuse.html</a></em></p>

<p>[4]virtiofs:
<em><a href="https://virtio-fs.gitlab.io/">https://virtio-fs.gitlab.io/</a></em></p>

<p>[5]runc 容器:
<em><a href="https://github.com/opencontainers/runc">https://github.com/opencontainers/runc</a></em></p>

<p>[6]Kata 容器:
<em><a href="https://katacontainers.io/">https://katacontainers.io/</a></em></p>

<p>[7]OSS 对象存储:
<em><a href="https://www.alibabacloud.com/product/oss">https://www.alibabacloud.com/product/oss</a></em></p>

<p>[8]Nydus-snapshotter:
<em><a href="https://github.com/containerd/nydus-snapshotter">https://github.com/containerd/nydus-snapshotter</a></em></p>

<p>[9]fuse-overlayfs:
<em><a href="https://github.com/containers/fuse-overlayfs">https://github.com/containers/fuse-overlayfs</a></em></p>

<p>[10]5.19 版本:
<em><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=65965d9530b0c320759cd18a9a5975fb2e098462">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=65965d9530b0c320759cd18a9a5975fb2e098462</a></em></p>

<p>[11]对于容器镜像使用者:
<em><a href="https://mp.weixin.qq.com/s/yC-UmMSDja959K9i_jSucQ">https://mp.weixin.qq.com/s/yC-UmMSDja959K9i_jSucQ</a></em></p>

<h2 id="本周推荐阅读">本周推荐阅读</h2>

<p><a href="http://mp.weixin.qq.com/s?__biz=MzUzMzU5Mjc1Nw==&amp;mid=2247510940&amp;idx=1&amp;sn=b545e0836a6182abddd13a05b2f90ba9&amp;chksm=faa34446cdd4cd50a461f071cdc4d871bd6eeef2318a2ec73968c117b41740a56a296c726aee&amp;scene=21">Nydus —— 下一代容器镜像的探索实践</a></p>

<p><a href="http://mp.weixin.qq.com/s?__biz=MzUzMzU5Mjc1Nw==&amp;mid=2247504035&amp;idx=1&amp;sn=320b77bf5f3c6cf0da309f7527b98e64&amp;chksm=faa33f79cdd4b66f184d273a2d7460c41320711eab47af849e386c359e71eeebc6c7f21c1e0f&amp;scene=21">Nydus 镜像加速插件迁入 Containerd 旗下</a></p>

<p><a href="http://mp.weixin.qq.com/s?__biz=MzUzMzU5Mjc1Nw==&amp;mid=2247516398&amp;idx=1&amp;sn=2172b6f6ffe9c8b3263a15ef60ee3d54&amp;chksm=faa36f34cdd4e622746582f922cd00798a1044c4f32a7ce058be6df91b58cbee725022a56525&amp;scene=21">cgo 机制 - 从 c 调用 go</a></p>

<p><a href="http://mp.weixin.qq.com/s?__biz=MzUzMzU5Mjc1Nw==&amp;mid=2247516354&amp;idx=1&amp;sn=804c45c191a9e319d4a47135e301f91a&amp;chksm=faa36f18cdd4e60e445dd9b4acfe51e40e2060349199e6160811ca069c2c54270d42ec0ca2b7&amp;scene=21">从规模化平台工程实践，我们学到了什么？</a></p>

</article>

<script>
  const article = document.querySelector('article.typo')
  
  const imgElements = article.querySelectorAll('img');
  
  imgElements.forEach(img => {
    const src = img.getAttribute('src');
    
    
      
    
    img.setAttribute('referrerpolicy', 'no-referrer');
  });
</script>


		<div class="-show-mobile">
			

<nav class="ss-pagination-next">
	<a class="link-prev" href="https://sofastack.github.io/sofastack.tech/blog/sofa-weekly-20221104/">
		<span class="text">上一篇: </span>
		<span class="text">SOFA Weekly | 开源人、本周 Contributor &amp; QA</span>
	</a>
	<a class="link-next" href="https://sofastack.github.io/sofastack.tech/blog/sofa-weekly-20221111/">
		<span class="text">下一篇: </span>
		<span class="text">SOFA Weekly | 本周贡献 &amp; issue 精选</span>
	</a>
</nav>

		</div>
	</main>

	<aside class="ss-layout-aside">
		
		


<div class="ss-card">
	<h2 class="card-title">
		相关推荐
	</h2>
	
	<ul class="ss-aside-related">
		
			<li><a href="/sofastack.tech/blog/c-go-mechanism-calling-go-from-c/20221008/">cgo 机制 - 从 c 调用 go</a></li>
		
			<li><a href="/sofastack.tech/blog/20220929/">开源项目文档社区化！Tongsuo/铜锁实践</a></li>
		
			<li><a href="/sofastack.tech/blog/sofastack20220927/">从规模化平台工程实践，我们学到了什么？</a></li>
		
			<li><a href="/sofastack.tech/blog/20220920/">Seata AT 模式代码级详解</a></li>
		
			<li><a href="/sofastack.tech/blog/is-pprof-enough-for-go-memory-leak/">Go 内存泄漏，pprof 够用了吗？</a></li>
		
	</ul>
	
</div>

		<div class="ss-aside-tags ss-card">
	<h2 class="card-title">
		标签
		<span class="card-extra"></span>
	</h2>
	<ul class="tag-list">
		
			<li class="tag"><a href="/sofastack.tech/tags/1024/">1024</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/api-gateway/">API Gateway </a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/cafedeployment/">CafeDeployment</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/cloud-native/">Cloud Native</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/cncf/">CNCF</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/db-mesh/">DB Mesh</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/dragonfly/">Dragonfly</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/elasticdl/">ElasticDL</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/http/3/">HTTP/3</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/http/quic/">HTTP/QUIC</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/kata-container/">Kata Container</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/kata-containers/">Kata Containers</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/knative/">Knative</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/kubecon/">KubeCon</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/kubernetes/">Kubernetes</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/meetup/">Meetup</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/mosn/">MOSN</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/nydus/">Nydus</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/occlum/">Occlum</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/rpc-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%80%83%E5%92%8C%E9%87%8F/">RPC 框架设计的考和量</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/seata/">seata</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/serverless/">Serverless</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/serverlesstask/">ServerlessTask</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/service-mesh/">Service mesh</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/service-mesh-meetup/">Service Mesh Meetup</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/service-mesh-virtual-meetup/">Service Mesh Virtual Meetup</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/service-mesh-webinar/">Service Mesh Webinar</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/service-mesh-%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/">Service Mesh 落地实践</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sidecar-%E5%AE%B9%E5%99%A8/">Sidecar 容器</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofa/">SOFA</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofa-weekly/">SOFA Weekly</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofaacts/">SOFAActs</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofaark/">SOFAArk</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofaarklab/">SOFAArkLab</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofabolt/">SOFABolt</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofaboot/">SOFABoot</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofachannel/">SOFAChannel</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofadashboard/">SOFADashboard</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofaenclave/">SOFAEnclave</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofajraft/">SOFAJRaft</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofajraft-%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90/">SOFAJRaft 特性解析</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofalab/">SOFALab</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofalookout/">SOFALookout</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofameetup/">SOFAMeetup</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofamesh/">SOFAMesh</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofaregistry/">SOFARegistry</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofarpc/">SOFARPC</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofastack/">SOFAStack</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofastack-%E5%BC%80%E6%BA%90%E4%B9%8B%E5%A4%8F/">SOFAStack 开源之夏</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofastak/">SOFAStak</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofatalk/">SOFATalk</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sofatracer/">SOFATracer</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/springboot/">SpringBoot</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/sqlflow/">SQLFlow</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/summer-2021/">Summer 2021</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/workshop/">Workshop</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/zsearch/">ZSearch</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E4%BD%A0%E7%9A%84%E5%BC%80%E6%BA%90%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/">你的开源入门指南</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">分布式事务</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/">分布式架构</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%89%96%E6%9E%90-sofaark-%E6%BA%90%E7%A0%81/">剖析 | SOFAArk 源码 </a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%89%96%E6%9E%90-sofabolt-%E6%A1%86%E6%9E%B6/">剖析 | SOFABolt 框架</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%89%96%E6%9E%90-sofaboot-%E6%A1%86%E6%9E%B6/">剖析 | SOFABoot 框架</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%89%96%E6%9E%90-sofajraft-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">剖析 | SOFAJRaft 实现原理</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%89%96%E6%9E%90-sofaregistry-%E6%A1%86%E6%9E%B6/">剖析 | SOFARegistry 框架</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%89%96%E6%9E%90-sofarpc-%E6%A1%86%E6%9E%B6/">剖析 | SOFARPC 框架</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%89%96%E6%9E%90-sofatracer-%E6%A1%86%E6%9E%B6/">剖析 | SOFATracer 框架</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%AE%9E%E8%B7%B5/">实践</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%BC%80%E6%BA%90/">开源</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%BC%80%E6%BA%90%E4%B9%8B%E5%A4%8F/">开源之夏</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%BC%80%E6%BA%90%E4%BA%94%E5%91%A8%E5%B9%B4/">开源五周年</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%BC%80%E6%BA%90%E5%85%AD%E5%91%A8%E5%B9%B4/">开源六周年</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%BC%80%E6%BA%90%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%BC%94%E8%BF%9B%E4%B8%8E%E6%9C%AA%E6%9D%A5/">开源容器镜像加速服务的演进与未来</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%BC%B9%E6%80%A7%E4%BC%B8%E7%BC%A9/">弹性伸缩</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E6%96%87%E4%BB%B6%E5%92%8C%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E7%B3%BB%E7%BB%9F/">文件和镜像加速系统</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E6%99%BA%E8%83%BD%E7%9B%91%E6%8E%A7/">智能监控</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E6%99%BA%E8%83%BD%E8%BF%90%E7%BB%B4/">智能运维</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E6%BA%90%E5%88%9B%E4%BC%9A/">源创会</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">源码解析</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E7%B1%BB%E9%9A%94%E7%A6%BB%E6%A1%86%E6%9E%B6/">类隔离框架</a></li>
		
			<li class="tag"><a href="/sofastack.tech/tags/%E9%95%9C%E5%83%8F/">镜像</a></li>
		
	</ul>
</div>
	</aside>
</div>



	


<footer class="ss-footer">
	<div class="container">
		<div class="links">
			
				<div class="cate">
					<h2 class="cate-title">资源</h2>
					
						<a class="link" href="https://github.com/sofastack">Github</a>
					
						<a class="link" href="https://gitee.com/sofastack/">Gitee</a>
					
						<a class="link" href="https://github.com/sofastack-guides">示例</a>
					
				</div>
			
				<div class="cate">
					<h2 class="cate-title">社交媒体</h2>
					
						<a class="link" href="https://zhuanlan.zhihu.com/sofastack">知乎专栏</a>
					
						<a class="link" href="https://weibo.com/sofastack">新浪微博</a>
					
						<a class="link" href="https://twitter.com/sofastack_io">Twitter</a>
					
				</div>
			
				<div class="cate">
					<h2 class="cate-title">参与进来</h2>
					
						<a class="link" href="https://github.com/sofastack/sofastack.tech/issues/new">反馈</a>
					
						<a class="link" href="https://github.com/sofastack/community">社区</a>
					
						<a class="link" href="https://github.com/sofastack/sofastack.tech/wiki">Wiki</a>
					
						<a class="link" href="mailto:sofa@alipay.cloud.com">Email</a>
					
						<a class="link" href="/hr/">加入我们</a>
					
				</div>
			
				<div class="cate">
					<h2 class="cate-title">蚂蚁集团开源项目</h2>
					
						<a class="link" href="https://ant.design/">Ant Design</a>
					
						<a class="link" href="https://eggjs.org/">Egg </a>
					
						<a class="link" href="https://sqlflow.org">SQLFlow</a>
					
						<a class="link" href="https://tech.antfin.com/open-source">更多</a>
					
				</div>
			
		</div>
		<div class="qrcode">
			
				<div>
					<img class="qrcode-img" src="/sofastack.tech/img/qrcode/qrcode_video_2024.jpg" />
					<p class="qrcode-desc">微信视频号</p>
				</div>
			
				<div>
					<img class="qrcode-img" src="/sofastack.tech/img/qrcode/qrcode_1_2024.jpg" />
					<p class="qrcode-desc">微信公众号</p>
				</div>
			
				<div>
					<img class="qrcode-img" src="/sofastack.tech/img/qrcode/dingtalk_qrcode_20241118.png" />
					<p class="qrcode-desc">钉钉群</p>
				</div>
			
		</div>
	</div>
	<div class="copyright">
		<p>
			© 2018 - 2022  The SOFAStack Authors
			<a href="http://beian.miit.gov.cn/">浙 ICP 备 16045294 号-3</a>
		</p>
	</div>
</footer>

</body>

</html>